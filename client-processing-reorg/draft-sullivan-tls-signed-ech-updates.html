<!DOCTYPE html>
<html lang="en" class="Internet-Draft">
<head>
<meta charset="utf-8">
<meta content="Common,Latin" name="scripts">
<meta content="initial-scale=1.0" name="viewport">
<title>Authenticated ECH Config Distribution and Rotation</title>
<meta content="Nick Sullivan" name="author">
<meta content="Martin Thomson" name="author">
<meta content="Dennis Jackson" name="author">
<meta content="
       Encrypted ClientHello (ECH) configurations need to be delivered to clients and rotated regularly for security. This document specifies an authenticated mechanism for in-band delivery and rotation of ECH configurations. 
       A new TLS 1.3 encrypted extension,  ech_config_update , allows servers to push updated ECHConfigList values to clients during a handshake. Authenticity is ensured via digital signatures or proofs. ECHConfig objects are treated as signed artifacts using one of three methods: 
       
           A Raw Public Key (RPK) pinned via a hash in the ECH config 
         
         
           A PKIX certificate with a dedicated Extended Key Usage for ECH signing 
         
         
           A DNSSEC-validated DNS resource record 
         
       
       A new ECHConfig extension,  ech_update_auth , advertises the server's supported update authentication methods. Clients announce their supported methods. If a match is found, the server delivers a signed ECHConfigList update in the handshake. 
       This design decouples ECH configuration authenticity from any particular transport (DNS, HTTPS, or TLS). Instead, it relies on the carried signature or proof. The mechanism updates ECH by allowing the server to send authenticated, updated ECH configurations during TLS handshakes without relying on the TLS certificate layer for authenticity. This is particularly valuable for correcting errors when clients use expired or outdated keys. 
       The result is a simple, robust framework for securely distributing and rotating ECH keys, suitable for standardization on the TLS Working Group track. 
    " name="description">
<meta content="xml2rfc 3.30.2" name="generator">
<meta content="TLS 1.3" name="keyword">
<meta content="Encrypted ClientHello" name="keyword">
<meta content="ECH" name="keyword">
<meta content="Key Rotation" name="keyword">
<meta content="DNSSEC" name="keyword">
<meta content="PKIX" name="keyword">
<meta content="RPK" name="keyword">
<meta content="draft-sullivan-tls-signed-ech-updates-latest" name="ietf.draft">
<!-- Generator version information:
  xml2rfc 3.30.2
    Python 3.12.11
    ConfigArgParse 1.7
    google-i18n-address 3.1.1
    intervaltree 3.1.0
    Jinja2 3.1.6
    lxml 5.3.1
    platformdirs 4.4.0
    pycountry 24.6.1
    PyYAML 6.0.2
    requests 2.32.5
    setuptools 80.9.0
    wcwidth 0.2.13
-->
<link href="draft-sullivan-tls-signed-ech-updates.xml" rel="alternate" type="application/rfc+xml">
<link href="#copyright" rel="license">
<style type="text/css">@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}

@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-cyrillic.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-cyrillic.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: local('Lora SemiBold'), local('Lora-SemiBold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-semibold-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Oxygen Mono';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Oxygen Mono'), local('OxygenMono-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/oxygenmono-regular-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Oxygen Mono';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Oxygen Mono'), local('OxygenMono-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/oxygenmono-regular-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: italic;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-italic-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C8A, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: italic;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-italic-cyrillic.woff2') format('woff2');
  unicode-range: U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: italic;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-italic-greek.woff2') format('woff2');
  unicode-range: U+0370-0377, U+037A-037F, U+0384-038A, U+038C, U+038E-03A1, U+03A3-03FF;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: italic;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-italic-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-02BA, U+02BD-02C5, U+02C7-02CC, U+02CE-02D7, U+02DD-02FF, U+0304, U+0308, U+0329, U+1D00-1DBF, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: italic;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-italic-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: normal;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-regular-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C8A, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: normal;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-regular-cyrillic.woff2') format('woff2');
  unicode-range: U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: normal;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-regular-greek.woff2') format('woff2');
  unicode-range: U+0370-0377, U+037A-037F, U+0384-038A, U+038C, U+038E-03A1, U+03A3-03FF;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: normal;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-regular-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-02BA, U+02BD-02C5, U+02C7-02CC, U+02CE-02D7, U+02DD-02FF, U+0304, U+0308, U+0329, U+1D00-1DBF, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: normal;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-regular-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

:root {
  color-scheme: light dark;
  --background-color: #fff;
  --text-color: #222;
  --title-color: #191919;
  --link-color: #2a6496;
  --highlight-color: #f9f9f9;
  --line-color: #eee;
  --pilcrow-weak: #ddd;
  --pilcrow-strong: #bbb;
  --small-font-size: 14.5px;
  --font-mono: 'Oxygen Mono', monospace;
  --font-title: "Sofia Sans Semi Condensed", sans-serif;
  scrollbar-color: #bbb #eee;
}
body {
  max-width: 600px;
  margin: 75px auto;
  padding: 0 5px;
  color: var(--text-color);
  background-color: var(--background-color);
  font: 16px/22px "Lora", serif;
  scroll-behavior: smooth;
}

.ears {
  display: none;
}

/* headings */
section {
  clear: both;
}
.section-number {
  padding-right: 0.5em;
}
h1, h2, h3, h4, h5, h6 {
  font-family: var(--font-title);
  font-weight: 680;
  margin: 0.8em 0 0.3em;
  font-size-adjust: 0.5;
  color: var(--title-color);
}
h1#title {
  font-size: 32px;
  line-height: 40px;
  clear: both;
}
h1#title, h1#rfcnum {
  margin: 1.5em 0 0.2em;
}
h1#rfcnum + h1#title {
  margin: 0.2em 0;
}

h1, h2, h3 {
  font-size: 22px;
  line-height: 27px;
}
h4, h5, h6 {
  font-size: 20px;
  line-height: 24px;
}

/* general structure */
.author {
  padding-bottom: 0.3em;
  vertical-align: top;
}
#abstract+p {
  font-size: 18px;
  line-height: 24px;
}
#abstract+p code, #abstract+p samp, #abstract+p tt {
  font-size: 16px;
  line-height: 0;
}

p {
  padding: 0;
  margin: 0.5em 0;
  text-align: left;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: var(--highlight-color);
  border: 1px solid var(--line-color);
  border-radius: 3px;
  padding: 0.5em 1em 0;
  margin-bottom: 0.5em;
}
.alignRight.art-text pre {
  padding: 0;
  width: auto;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
/* font-family isn't space-separated, but =~ will have to do */
svg[font-family~="monospace" i], svg [font-family~="monospace" i] {
  font-family: var(--font-mono);
}
.alignCenter.art-text {
  background-color: var(--highlight-color);
  border: 1px solid var(--line-color);
  border-radius: 3px;
  padding: 0.5em 1em 0;
  margin-bottom: 0.5em;
}
.alignCenter.art-text pre {
  padding: 0;
  width: auto;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  border: none;
  /* this isn't optimal, but it's an existence proof.  PrinceXML doesn't
     support flexbox yet.
  */
  display: table;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 0.5em 2em;
  & :is(ol, ul) {
    margin-left: 1em;
  }
}
li {
  margin: 0 0 0.25em 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
  & li {
    margin-top: 0.5em;
  }
}
:is(ul, ol).compact, .ulCompact, .olCompact {
  margin: 0 0 0 2em;
  & li {
    margin: 0;
    & :first-child { margin-top: 0; }
    & :last-child { margin-bottom: 0; }
  }
}

/* definition lists */
dl {
  clear: left;
  --indent: 3ch;
  /* --indent: attr(indent ch); not supported in any browser, but we can dream */
  &.olPercent {
    --indent: 5ch;
    & > dt {
      min-width: calc(var(--indent) - 2ch);
    }
  }
  &.olPercent > dt {
    float: none;
  }

  dl > dd > & {
    margin-top: 0.5em;
    margin-bottom: 0;
  }
}
dl:not(.dlNewline) > dt {
  float: left;
  margin-right: 2ch;
  min-width: 8ch;
}
dl > dd {
  margin-bottom: .8em;
  margin-left: var(--indent) !important; /* stupid element overrides */
  min-height: 2ex;
}
:is(dl.compact, .dlCompact) > dd {
  margin-bottom: 0;
  & > :is(:first-child, .break:first-child + *) {
    margin-top: 0;
  }
  & > :is(:last-child) {
    margin-bottom: 0;
  }
}
:is(dd, span).break {
  display: none;
}

/* links */
a, a[href].selfRef:hover {
  text-decoration: none;
}
a[href] {
  color: var(--link-color);
}
a[href].selfRef, .iref + a[href].internal {
  color: var(--text-color);
}
a[href]:hover {
  text-decoration: underline;
}
a[href].selfRef:hover {
  background-color: var(--highlight-color);
}
a.xref:is(.cite, .auto), :is(#status-of-memo, #copyright) a {
  white-space: nowrap;
}

/* Figures */
tt, code, pre {
  background-color: var(--highlight-color);
  font: 14px/22px var(--font-mono);
}
tt, code {
  /* changing the font for inline elements leads to different ascender
     and descender heights; as we want to retain baseline alignment,
     remove leading to avoid altering the final height of lines
     note: this fails if these blocks take an entire line,
     a different solution would be great */
  line-height: 0;
}
:is(h1, h2, h3, h4, h5, h6) :is(tt, code) {
  font-size: 84%;
}
pre {
  border: 1px solid var(--line-color);
  font-size: 13.5px;
  line-height: 16px;
  letter-spacing: -0.2px;
  margin: 5px;
  padding: 5px;
}
img {
  max-width: 100%;
}
figure {
  margin: 0.5em 0;
  padding: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption, caption {
  font-style: italic;
  margin: 0.5em 1.5em;
  text-align: left;
  caption-side: bottom;
}
@media screen {
  /* Auto-collapse boilerplate. */
  :is(#status-of-memo, #copyright) p {
    margin: -2px 0;
    max-height: 0;
    transition: max-height 2s ease, margin 0.5s ease 0.5s;
    overflow: hidden;
  }
  :is(#status-of-memo, #copyright):hover p,
  :is(#status-of-memo, #copyright) h2:target ~ p {
    margin: 0.5em 0;
    max-height: 500px;
    overflow: auto;
  }
  pre, svg {
    display: inline-block;
    /* In the horizontal direction, sometimes people make over-sized figures.
       Scrollbars for those is therefore necessary: auto adds them as necessary..
       In the vertical direction, the line-height can combine with the font
       asender/descender height to produce scrollbars: hidden avoids that. */
    overflow: auto hidden;
  }
  pre {
    max-width: 100%;
    width: calc(100% - 22px - 1em);
  }
  svg {
    max-width: calc(100% - 22px - 1em);
  }
  figure pre {
    display: block;
    width: calc(100% - 25px);
  }
  :is(pre, svg) + .pilcrow {
    display: inline-block;
    vertical-align: text-bottom;
    padding-bottom: 8px;
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 0 2em;
  font-style: italic;
}
blockquote {
  margin: 1em 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}

/* tables */
table {
  width: auto;
  max-width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
}
table.right {
  margin-left: auto;
}
table.center {
  margin-left: auto;
  margin-right: auto;
}
table.left {
  margin-right: auto;
}
table .text-left {
  text-align: left;
}
table .text-center {
  text-align: center;
}
table .text-right {
  text-align: right;
}

thead, tbody {
  border: 1px solid var(--line-color);
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 5px 10px;
}
th {
  background-color: var(--line-color);
}
:is(tr:nth-child(2n), thead+tbody > tr:nth-child(2n+1)) > td {
  background-color: var(--background-color);
}
:is(tr:nth-child(2n+1), thead+tbody > tr:nth-child(2n)) > td {
  background-color: var(--highlight-color);
}
table caption {
  margin: 0;
  padding: 3px 0 3px 1em;
}
table p {
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  margin-left: 3px;
  opacity: 0.2;
  user-select: none;
  &[href] {
    color: var(--pilcrow-weak);
    &:hover { text-decoration: none; }
  }
}
@media not print {
  :hover > a.pilcrow {
    opacity: 1;
  }
  a.pilcrow[href]:hover {
    color: var(--pilcrow-strong);
    background-color: transparent;
  }
}
@media print {
  a.pilcrow {
    display: none;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid var(--line-color);
}
.bcp14 {
  font-variant: small-caps;
  font-weight: 600;
  font-size: var(--small-font-size);
}
.role {
  font-variant: all-small-caps;
}
sub, sup {
  line-height: 1;
  font-size: 80%;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: var(--small-font-size);
  line-height: 18px;
  --identifier-width: 15ch;
  & dt {
    width: var(--identifier-width);
    min-width: var(--identifier-width);
    clear: left;
    float: left;
    text-align: right;
    margin-right: 1ch;
  }
  & dd {
    margin: 0;
    margin-left: calc(1em + var(--identifier-width)) !important;
    min-width: 5em;
  }
  & .authors {
    & .author {
      display: inline-block;
      margin-right: 1.5em;
    }
    & .org {
      font-style: italic;
    }
  }
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #999;
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;

  & nav {
    & ul {
      margin: 0 0.5em 0 0;
      padding: 0;
      list-style: none;
    }
    & li {
      line-height: 1.3em;
      margin: 2px 0;
      padding-left: 1.2em;
      text-indent: -1.2em;
    }
  }
  & a.xref {
    white-space: normal;
  }
}

.references {
  & > dt {
    text-align: right;
    font-weight: bold;
    min-width: 10ch;
    margin-right: 1.5ch;
    &:target::before {
      content: "⇒";
      margin: 0 10px 0 -25px;
    }
  }
  & > dd {
    margin-left: 12ch !important;
    overflow: visible;
    & .refInstance {
      margin-bottom: 0.8em;
    }
    & .ascii {
      margin-bottom: 0.25em;
    }
  }
}

#rfc\.index\.index + ul {
  margin-left: 0;
}

/* authors */
address.vcard {
  font-style: normal;
  max-width: 20em;
  margin: 1em auto 1em 0;

  & .nameRole {
    font-weight: 700;
    margin-left: 0;
  }
  & .label {
    margin: 0.5em 0;
  }
  & .type {
    display: none;
  }
  & .alternative-contact {
    margin: 0.5em 0 0.25em 0;
  }
  & .non-ascii {
    margin: 0 0 0 2em;
  }
  & div.left {
    text-align: left;
  }
  & div.right {
    text-align: right;
  }
}

hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}
@media (min-width: 500px) {
  #authors-addresses > section {
    column-count: 2;
    column-gap: 20px;
  }
  #authors-addresses > section > h2 {
    column-span: all;
  }
  /* hack for break-inside: avoid-column */
  #authors-addresses address {
    display: inline-block;
    break-inside: avoid-column;
  }
}

/* Comments */
.rfcEditorRemove p:first-of-type {
  font-style: italic;
}
.cref {
  background-color: rgba(249, 232, 105, 0.3);
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}

@media screen {
  #toc nav {
    font-family: var(--font-title);
    font-weight: 360;
    & > ul { margin-bottom: 2em; }
    & ul {
      margin: 0 0 0 4px;
      & :is(p, li) {
        margin: 2px 0;
      }
    }
  }
  #toc a.toplink {
    float: right;
  }
}
@media not screen {
  #toc a.toplink {
    display: none;
  }
}


/* TOC layout for smaller screens */
@media screen and (max-width: 929px) {
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 1px 0 0 0;
    margin: 0;
    border-bottom: 1px solid #ccc;
    opacity: 0.6;
  }
  #toc h2 {
    margin: 0;
    padding: 2px 0 2px 6px;
    padding-right: 1em;
    font-size: 18px;
    line-height: 24px;
    min-width: 190px;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
    &::before { /* css hamburger */
      float: right;
      position: relative;
      width: 1em;
      height: 1px;
      left: -164px;
      margin: 8px 0 0 0;
      background: white none repeat scroll 0 0;
      box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
      content: "";
    }
  }
  #toc nav {
    display: none;
    background-color: var(--background-color);
    padding: 0.5em 1em 1em;
    overflow: auto;
    overscroll-behavior: contain;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
  #toc.active {
    opacity: 1;
    & nav { display: block; }
  }
  /* Make the collapsed ToC header render white on gray also when it's a link */
  #toc h2 a,
  #toc h2 a:is(:link, :focus, :hover),
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
  #toc a.toplink {
    margin: 2px 0.5em 0;
  }
}

/* TOC layout for wide screens */
@media screen and (min-width: 930px) {
  body {
    padding-right: 360px;
    padding-right: calc(min(180px + 20%, 500px));
  }
  #toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 480px);
    width: 312px;
    margin: 0;
    padding: 0;
    z-index: 1;
  }
  #toc h2 {
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 2em;
    overflow: auto;
    overscroll-behavior: contain;
    scrollbar-width: thin;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
  #toc a.toplink {
    margin: 8px 0.5em 0;
  }
}

/* pagination */
@media print {
  body {
    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre, .vcard {
    page-break-inside: avoid;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  :is(h2, h3, h4, h5, h6)+*, dd {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
}

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
}

/* Dark mode. */
@media (prefers-color-scheme: dark) {
:root {
  --background-color: #121212;
  --text-color: #f0f0f0;
  --title-color: #fff;
  --link-color: #4da4f0;
  --highlight-color: #282828;
  --line-color: #444;
  --pilcrow-weak: #444;
  --pilcrow-strong: #666;
  scrollbar-color: #777 #333;
}
}

/* SVG Trick: a prefix match works because only black and white are allowed */
svg :is([stroke="black"], [stroke^="#000"]) {
  stroke: var(--text-color);
}
svg :is([stroke="white"], [stroke^="#fff"]) {
  stroke: var(--background-color);
}
svg :is([fill="black"], [fill^="#000"], :not([fill])) {
  fill: var(--text-color);
}
svg :is([fill="white"], [fill^="#fff"]) {
  fill: var(--background-color);
}
</style>

</head>
<body class="xml2rfc">
<table class="ears">
<thead><tr>
<td class="left">Internet-Draft</td>
<td class="center">Authenticated ECH Update</td>
<td class="right">September 2025</td>
</tr></thead>
<tfoot><tr>
<td class="left">Sullivan, et al.</td>
<td class="center">Expires 28 March 2026</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div id="external-metadata" class="document-information"></div>
<div id="internal-metadata" class="document-information">
<dl id="identifiers">
<dt class="label-workgroup">Workgroup:</dt>
<dd class="workgroup">TLS</dd>
<dt class="label-internet-draft">Internet-Draft:</dt>
<dd class="internet-draft">draft-sullivan-tls-signed-ech-updates-latest</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time datetime="2025-09-24" class="published">24 September 2025</time>
    </dd>
<dt class="label-intended-status">Intended Status:</dt>
<dd class="intended-status">Standards Track</dd>
<dt class="label-expires">Expires:</dt>
<dd class="expires"><time datetime="2026-03-28">28 March 2026</time></dd>
<dt class="label-authors">Authors:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">N. Sullivan</div>
<div class="org">Cryptography Consulting LLC</div>
</div>
<div class="author">
      <div class="author-name">M. Thomson</div>
<div class="org">Mozilla</div>
</div>
<div class="author">
      <div class="author-name">D. Jackson</div>
<div class="org">Mozilla</div>
</div>
</dd>
</dl>
</div>
<h1 id="title">Authenticated ECH Config Distribution and Rotation</h1>
<section id="section-abstract">
      <h2 id="abstract"><a href="#abstract" class="selfRef">Abstract</a></h2>
<p id="section-abstract-1">Encrypted ClientHello (ECH) configurations need to be delivered to clients and rotated regularly for security. This document specifies an authenticated mechanism for in-band delivery and rotation of ECH configurations.<a href="#section-abstract-1" class="pilcrow">¶</a></p>
<p id="section-abstract-2">A new TLS 1.3 encrypted extension, <code>ech_config_update</code>, allows servers to push updated ECHConfigList values to clients during a handshake. Authenticity is ensured via digital signatures or proofs. ECHConfig objects are treated as signed artifacts using one of three methods:<a href="#section-abstract-2" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-abstract-3">
<li id="section-abstract-3.1">
          <p id="section-abstract-3.1.1">A Raw Public Key (RPK) pinned via a hash in the ECH config<a href="#section-abstract-3.1.1" class="pilcrow">¶</a></p>
</li>
        <li id="section-abstract-3.2">
          <p id="section-abstract-3.2.1">A PKIX certificate with a dedicated Extended Key Usage for ECH signing<a href="#section-abstract-3.2.1" class="pilcrow">¶</a></p>
</li>
        <li id="section-abstract-3.3">
          <p id="section-abstract-3.3.1">A DNSSEC-validated DNS resource record<a href="#section-abstract-3.3.1" class="pilcrow">¶</a></p>
</li>
      </ol>
<p id="section-abstract-4">A new ECHConfig extension, <code>ech_update_auth</code>, advertises the server's supported update authentication methods. Clients announce their supported methods. If a match is found, the server delivers a signed ECHConfigList update in the handshake.<a href="#section-abstract-4" class="pilcrow">¶</a></p>
<p id="section-abstract-5">This design decouples ECH configuration authenticity from any particular transport (DNS, HTTPS, or TLS). Instead, it relies on the carried signature or proof. The mechanism updates ECH by allowing the server to send authenticated, updated ECH configurations during TLS handshakes without relying on the TLS certificate layer for authenticity. This is particularly valuable for correcting errors when clients use expired or outdated keys.<a href="#section-abstract-5" class="pilcrow">¶</a></p>
<p id="section-abstract-6">The result is a simple, robust framework for securely distributing and rotating ECH keys, suitable for standardization on the TLS Working Group track.<a href="#section-abstract-6" class="pilcrow">¶</a></p>
</section>
<section class="note rfcEditorRemove" id="section-note.1">
      <h2 id="name-about-this-document">
<a href="#name-about-this-document" class="section-name selfRef">About This Document</a>
      </h2>
<p id="section-note.1-1">This note is to be removed before publishing as an RFC.<a href="#section-note.1-1" class="pilcrow">¶</a></p>
<p id="section-note.1-2">
        Status information for this document may be found at <span><a href="https://datatracker.ietf.org/doc/draft-sullivan-tls-signed-ech-updates/">https://datatracker.ietf.org/doc/draft-sullivan-tls-signed-ech-updates/</a></span>.<a href="#section-note.1-2" class="pilcrow">¶</a></p>
<p id="section-note.1-3">Source for this draft and an issue tracker can be found at
        <span><a href="https://github.com/grittygrease/draft-sullivan-tls-signed-ech-updates">https://github.com/grittygrease/draft-sullivan-tls-signed-ech-updates</a></span>.<a href="#section-note.1-3" class="pilcrow">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a href="#name-status-of-this-memo" class="section-name selfRef">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
        This Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.<a href="#section-boilerplate.1-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-2">
        Internet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at <span><a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a></span>.<a href="#section-boilerplate.1-2" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-3">
        Internet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."<a href="#section-boilerplate.1-3" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-4">
        This Internet-Draft will expire on 28 March 2026.<a href="#section-boilerplate.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a href="#name-copyright-notice" class="section-name selfRef">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2025 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a href="#section-boilerplate.2-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.<a href="#section-boilerplate.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a href="#" onclick="scroll(0,0)" class="toplink">▲</a><h2 id="name-table-of-contents">
<a href="#name-table-of-contents" class="section-name selfRef">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1" class="keepWithNext"><a href="#section-1" class="auto internal xref">1</a>.  <a href="#name-introduction" class="internal xref">Introduction</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1" class="keepWithNext"><a href="#section-2" class="auto internal xref">2</a>.  <a href="#name-conventions-and-definitions" class="internal xref">Conventions and Definitions</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1" class="keepWithNext"><a href="#section-3" class="auto internal xref">3</a>.  <a href="#name-ech-update-auth-ech-extensi" class="internal xref">ECH Update Auth ECH Extension</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a href="#section-4" class="auto internal xref">4</a>.  <a href="#name-design-details-and-wire-for" class="internal xref">Design Details and Wire Formats</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a href="#section-5" class="auto internal xref">5</a>.  <a href="#name-echconfig-metadata-ech_upda" class="internal xref">ECHConfig Metadata: <code>ech_update_auth</code> (ECHConfig extension)</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a href="#section-6" class="auto internal xref">6</a>.  <a href="#name-clienthello-extension-for-u" class="internal xref">ClientHello Extension for Update Method Support</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a href="#section-7" class="auto internal xref">7</a>.  <a href="#name-tls-encryptedextension-ech_" class="internal xref">TLS EncryptedExtension: <code>ech_config_update</code></a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a href="#section-8" class="auto internal xref">8</a>.  <a href="#name-client-processing" class="internal xref">Client Processing</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a href="#section-9" class="auto internal xref">9</a>.  <a href="#name-server-behavior" class="internal xref">Server Behavior</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a href="#section-10" class="auto internal xref">10</a>. <a href="#name-client-behavior" class="internal xref">Client Behavior</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11">
            <p id="section-toc.1-1.11.1"><a href="#section-11" class="auto internal xref">11</a>. <a href="#name-public-name-authentication-" class="internal xref">Public Name Authentication for Retry</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12">
            <p id="section-toc.1-1.12.1"><a href="#section-12" class="auto internal xref">12</a>. <a href="#name-privacy-considerations-in-m" class="internal xref">Privacy Considerations in Mechanism</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13">
            <p id="section-toc.1-1.13.1"><a href="#section-13" class="auto internal xref">13</a>. <a href="#name-example-exchange-informativ" class="internal xref">Example Exchange (Informative)</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14">
            <p id="section-toc.1-1.14.1"><a href="#section-14" class="auto internal xref">14</a>. <a href="#name-security-considerations" class="internal xref">Security Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.15">
            <p id="section-toc.1-1.15.1"><a href="#section-15" class="auto internal xref">15</a>. <a href="#name-privacy-considerations" class="internal xref">Privacy Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.16">
            <p id="section-toc.1-1.16.1"><a href="#section-16" class="auto internal xref">16</a>. <a href="#name-iana-considerations" class="internal xref">IANA Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.17">
            <p id="section-toc.1-1.17.1"><a href="#section-17" class="auto internal xref">17</a>. <a href="#name-retry-state-machine" class="internal xref">Retry State Machine</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.18">
            <p id="section-toc.1-1.18.1"><a href="#section-18" class="auto internal xref">18</a>. <a href="#name-deployment-considerations" class="internal xref">Deployment Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.19">
            <p id="section-toc.1-1.19.1"><a href="#section-19" class="auto internal xref">19</a>. <a href="#name-reserved-code-points" class="internal xref">Reserved Code Points</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.20">
            <p id="section-toc.1-1.20.1"><a href="#section-20" class="auto internal xref">20</a>. <a href="#name-references" class="internal xref">References</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.20.2.1">
                <p id="section-toc.1-1.20.2.1.1"><a href="#section-20.1" class="auto internal xref">20.1</a>.  <a href="#name-normative-references" class="internal xref">Normative References</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.20.2.2">
                <p id="section-toc.1-1.20.2.2.1"><a href="#section-20.2" class="auto internal xref">20.2</a>.  <a href="#name-informative-references" class="internal xref">Informative References</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.21">
            <p id="section-toc.1-1.21.1"><a href="#appendix-A" class="auto internal xref"></a><a href="#name-authors-addresses" class="internal xref">Authors' Addresses</a></p>
</li>
        </ul>
</nav>
</section>
</div>
<div id="introduction">
<section id="section-1">
      <h2 id="name-introduction">
<a href="#section-1" class="section-number selfRef">1. </a><a href="#name-introduction" class="section-name selfRef">Introduction</a>
      </h2>
<p id="section-1-1">Deployment of TLS Encrypted ClientHello (ECH) requires that clients obtain the server's current ECH configuration (ECHConfig) before initiating a connection. Existing mechanisms to distribute ECHConfig data include publishing it in DNS via the HTTPS resource record <span>[<a href="#RFC9460" class="cite xref">RFC9460</a>]</span> or via an HTTPS well-known URI<span>[<a href="#I-D.ietf-tls-wkech" class="cite xref">I-D.ietf-tls-wkech</a>]</span>.<a href="#section-1-1" class="pilcrow">¶</a></p>
<p id="section-1-2">These mechanisms allow an origin to provide clients with its ECHConfigList (a sequence of one or more ECHConfig structures) prior to connection establishment. Each ECHConfig includes the public key for HPKE encryption per <span>[<a href="#RFC9180" class="cite xref">RFC9180</a>]</span>. However, out-of-band distribution alone can be insufficient for timely rotation of ECH keys or for ensuring authenticity in all scenarios.<a href="#section-1-2" class="pilcrow">¶</a></p>
<p id="section-1-3">For example, not all clients perform DNSSEC validation. Additionally, reliance on the Web PKI for delivering ECHConfig via HTTPS ties ECH key authenticity to the certificate infrastructure.<a href="#section-1-3" class="pilcrow">¶</a></p>
<p id="section-1-4">ECH provides a "retry" fallback mechanism to recover when a client's ECHConfig is incorrect or outdated<span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span>. In TLS 1.3, servers may send a new ECHConfigList to the client as part of the handshake, using either a HelloRetryRequest or an EncryptedExtensions message.<a href="#section-1-4" class="pilcrow">¶</a></p>
<p id="section-1-5">In the base ECH design, however, clients are instructed to ignore any ECH configs delivered in the handshake and not to cache them. Instead, the server must authenticate the fallback connection using the public name's certificate (typically issued by a trusted CA). The client is expected to obtain updated ECH keys via DNS or other out-of-band means for future connections<span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span>.<a href="#section-1-5" class="pilcrow">¶</a></p>
<p id="section-1-6">This approach has limitations. It constrains the set of public names to those for which the operator can obtain certificates, reducing the anonymity set of public-facing hostnames. It also delays recovery from ECH key rotation, potentially causing additional latency or requiring clients to fall back to non-ECH connections when retry configs are unavailable.<a href="#section-1-6" class="pilcrow">¶</a></p>
<p id="section-1-7">This document introduces an Authenticated ECH Config Update mechanism to securely deliver and rotate ECHConfig data in-band, during a TLS handshake. The goal is to allow servers to frequently update ECH keys (for example, to limit the lifetime of keys or respond to compromise). This mechanism does not prescribe or rely on fallback; falling back to non-ECH can foil ECH deployments and is out of scope.<a href="#section-1-7" class="pilcrow">¶</a></p>
<p id="section-1-8">By authenticating ECH configs independently, the mechanism makes ECH key distribution orthogonal to transport. The same signed ECHConfig artifact can be conveyed via DNS, HTTPS, or the TLS handshake itself. The client will accept it only if the accompanying signature or proof is valid under one of its trust modes.<a href="#section-1-8" class="pilcrow">¶</a></p>
</section>
</div>
<div id="conventions-and-definitions">
<section id="section-2">
      <h2 id="name-conventions-and-definitions">
<a href="#section-2" class="section-number selfRef">2. </a><a href="#name-conventions-and-definitions" class="section-name selfRef">Conventions and Definitions</a>
      </h2>
<p id="section-2-1">The key words <strong>"MUST"</strong>, <strong>"MUST NOT"</strong>, <strong>"SHOULD"</strong>, <strong>"SHOULD NOT"</strong>, and <strong>"MAY"</strong> in this document are to be interpreted as described in BCP 14 (<span>[<a href="#RFC2119" class="cite xref">RFC2119</a>]</span>, <span>[<a href="#RFC8174" class="cite xref">RFC8174</a>]</span>) when, and only when, they appear in all capitals.<a href="#section-2-1" class="pilcrow">¶</a></p>
<p id="section-2-2">This document assumes familiarity with TLS 1.3 <span>[<a href="#RFC8446" class="cite xref">RFC8446</a>]</span> and the ECH specification (<span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span>, referred to here as simply "ECH"). The term "ECHConfigList" refers to the sequence of one or more ECHConfig structures as defined in ECH (a byte string that starts with a 16-bit length and may contain multiple concatenated ECHConfig values)<span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span>. The term "ECHConfig" refers to an individual configuration, which includes fields such as <code>public_name</code>, <code>public_key</code> (HPKE key), and so on, as defined in the ECH draft. We also use "public name" to mean the plaintext DNS name used in the ClientHelloOuter (the outer SNI), and "hidden name" or "originname" to mean the actual server name intended by the client (carried in the encrypted ClientHelloInner).<a href="#section-2-2" class="pilcrow">¶</a></p>
<p id="section-2-3">The reader should recall that in TLS 1.3, the server's EncryptedExtensions message is encrypted and integrity-protected with handshake keys<span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span>. New extensions defined as part of EncryptedExtensions are not visible to network attackers and cannot be modified by an attacker without detection. Additionally, "certificate verification" refers to the standard X.509 validation process (chain building, signature and expiration checking, name matching, etc.), unless otherwise specified.<a href="#section-2-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="ech-update-auth-ech-extension">
<section id="section-3">
      <h2 id="name-ech-update-auth-ech-extensi">
<a href="#section-3" class="section-number selfRef">3. </a><a href="#name-ech-update-auth-ech-extensi" class="section-name selfRef">ECH Update Auth ECH Extension</a>
      </h2>
<p id="section-3-1">In this mechanism, each ECHConfig (as defined in <span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span>) may carry an <code>ech_update_auth</code> extension that specifies how the configuration can be updated in the future. This extension includes a bitmask of supported authentication methods. The three authentication methods defined in this document are:<a href="#section-3-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-3-2">
<li id="section-3-2.1">
          <p id="section-3-2.1.1">Raw Public Key (RPK) – The ECHConfig is "pinned" to one or more public keys designated by the server for future updates. Specifically, the <code>ech_update_auth</code> extension can list one or more hashes of Subject Public Key Info (SPKI) values. The server possesses the corresponding private key(s) and will use one of them to sign any subsequent ECHConfigList updates. The update object MUST include the signer SPKI (or equivalent raw public key) so the client can hash and compare against pins.<a href="#section-3-2.1.1" class="pilcrow">¶</a></p>
<p id="section-3-2.1.2">
Clients that have seen and stored these SPKI fingerprints will accept a new ECHConfigList only if it carries a valid digital signature made with one of the pinned keys. This provides a continuity-of-trust model: the first ECHConfig must be obtained securely (e.g., via DNSSEC or PKIX), after which updates can be authenticated by the pinned key without further external validation. Clients never advertise nor transmit anchors; they may cache pins implicitly.<a href="#section-3-2.1.2" class="pilcrow">¶</a></p>
<p id="section-3-2.1.3">
No key identifier is used in the update object – clients simply try the candidate public keys from the pin list until one produces a valid signature. This avoids exposing key IDs on the wire and reduces complexity. The update signature object includes its own validity interval (e.g., not-before and not-after timestamps), so explicit expiration or TTLs in DNS records are not required; the signature itself carries the time window during which the update is valid.<a href="#section-3-2.1.3" class="pilcrow">¶</a></p>
</li>
        <li id="section-3-2.2">
          <p id="section-3-2.2.1">PKIX (Certificate-Based) – The ECHConfigList update is signed using a private key for which the server can present a certificate chain. In the update message, the server includes an X.509 certificate (and any intermediates as needed) that chains to a trusted root. The certificate must contain a new Extended Key Usage (EKU) indicating authority to sign ECH configurations.<a href="#section-3-2.2.1" class="pilcrow">¶</a></p>
<p id="section-3-2.2.2">
The certificate's subject must cover the ECH public name (i.e., the plaintext SNI used for ECH) to prove that the signer is authoritative for that name. A client validates this method by verifying the certificate chain, checking the EKU, confirming the public name in the certificate, and then verifying the signature over the ECHConfigList using the certified public key.<a href="#section-3-2.2.2" class="pilcrow">¶</a></p>
<p id="section-3-2.2.3">
This method leverages the existing Web PKI trust model for authentication but uses a dedicated EKU to constrain the certificate's usage to ECH key management. It allows integration with traditional CAs for operators that prefer that, and it uses standard certificate validation procedures as defined in TLS.<a href="#section-3-2.2.3" class="pilcrow">¶</a></p>
</li>
        <li id="section-3-2.3">
          <p id="section-3-2.3.1">DNSSEC – The ECHConfigList is authenticated using the Domain Name System Security Extensions. In this method, the server provides a recent DNS record (or record set) that conveys the ECHConfigList (for example, an HTTPS RR with an <code>ech</code> SvcParam) along with the DNSSEC signatures and necessary proof chain (DNSKEY and DS records) needed for validation.<a href="#section-3-2.3.1" class="pilcrow">¶</a></p>
<p id="section-3-2.3.2">
The client performs DNSSEC validation on the provided records to ensure they were published by the owner of the domain name (the public name) and are current. If validation succeeds, the ECHConfigList contained in the DNS record is considered authentic.<a href="#section-3-2.3.2" class="pilcrow">¶</a></p>
<p id="section-3-2.3.3">
This method bootstraps trust in ECH keys from the global DNSSEC hierarchy rather than the Web PKI or a pinned key. It is especially useful for clients or deployments that already rely on DNSSEC-validating resolvers, and it aligns with the existing DNS-based ECH bootstrap mechanism in which authoritative DNS records carry the ECHConfigList<span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span>. Here, however, the proof is delivered in-band to the client, removing dependence on the client's local resolver for authenticity.<a href="#section-3-2.3.3" class="pilcrow">¶</a></p>
</li>
      </ol>
<p id="section-3-3">The server can indicate support for one or multiple of these methods by listing them in the <code>ech_update_auth</code> extension of its ECHConfig. For example, a configuration could specify that updates might be authenticated via either the RPK method or DNSSEC, allowing flexibility depending on client capabilities. The presence of <code>ech_update_auth</code> in an ECHConfig signals to the client that the server is willing to send authenticated config updates using the specified method(s).<a href="#section-3-3" class="pilcrow">¶</a></p>
<p id="section-3-4"></p>
<p id="section-3-5">By treating ECH configurations as signed objects, this mechanism <strong>decouples trust in ECH keys from the TLS handshake's certificate validation of the origin</strong>. In particular, it enables scenarios such as:
- Use of <strong>distinct public names without needing CA certificates</strong>: A server can use many different "public" hostnames (even per-client, per-connection unique ones) to maximize the anonymity set or for other operational reasons<span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span>, without having to obtain certificates for each. The RPK method (with SPKI pinning) allows the client to authenticate the server's ability to update ECH keys for those public names via a pinned key, rather than via a CA-issued cert. This was not possible under the original ECH design, which required a valid certificate for any public name used<span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span>. Now, the public name authentication can be achieved by proving possession of the pinned key. Section <span><a href="#public-name-auth" class="internal xref">Public Name Authentication</a> (<a href="#public-name-auth" class="auto internal xref">Section 11</a>)</span> describes how this applies to ECH retry handshakes.
- <strong>Faster and safer key rotation</strong>: The server can proactively push a new ECHConfig to clients shortly before rotating keys, ensuring clients receive it immediately. The update objects include a validity window, so a server could, for example, sign an update that becomes valid at a future time (and/or expires after a certain time) to coordinate key rollover. Clients will honor those constraints.
- <strong>Out-of-band distribution synergy</strong>: Because the same authentication methods are defined for in-band and out-of-band, an ECHConfig obtained via DNS can carry the same signature that a TLS in-band update would, allowing clients to verify it even if their DNS channel isn't fully trusted. For instance, a client might obtain an ECHConfig via DNS without DNSSEC; if that ECHConfig has an RPK pin, subsequent updates via TLS will be signed by that key, protecting against any earlier undetected DNS tampering. Similarly, a client that doesn't validate DNSSEC itself could still receive a DNSSEC-signed ECHConfig in the TLS handshake and validate it with the included DNSSEC proof, thus leveraging DNSSEC without requiring a local validating resolver.<a href="#section-3-5" class="pilcrow">¶</a></p>
<p id="section-3-6">Finally, this design attempts to <strong>minimize complexity</strong>. It does not use explicit key identifiers or complicated pin rotation metadata. The trust on first use model is kept simple (a list of allowed signing keys); pin revocation or addition is handled by simply signing a new update that changes the list (clients trust the new list if it's signed by a currently trusted key). There is no "next update time" field that requires clients to preemptively fetch updates; instead, updates are fetched when provided by the server or when the client next connects. The mechanism is agnostic to the transport by which the client obtained the initial ECHConfig – whether via DNS SVCB/HTTPS RR (as in <span><a href="#I-D.ietf-tls-esni" class="internal xref">I-D.ietf-tls-svcb-ech</a> [<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span>), via a well-known HTTPS endpoint<span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span>, or via some provisioning protocol, the subsequent updates use the same verification process.<a href="#section-3-6" class="pilcrow">¶</a></p>
<p id="section-3-7">The rest of this document is organized as follows. Section <span><a href="#wire-formats" class="internal xref">Design Details and Wire Format</a> (<a href="#wire-formats" class="auto internal xref">Section 4</a>)</span> defines the new TLS extension <code>ech_config_update</code> and its structure, along with the ClientHello extension and the ECHConfig <code>ech_update_auth</code> extension. Section Client and Server Behavior describes the state machine and processing rules for clients and servers, including how to handle retry handshakes and how to apply updates. Section <span><a href="#security" class="internal xref">Security Considerations</a> (<a href="#security" class="auto internal xref">Section 14</a>)</span> discusses the security properties of this mechanism, including trust on first use risks, replay and freshness, and privacy implications. Section <span><a href="#iana" class="internal xref">IANA Considerations</a> (<a href="#iana" class="auto internal xref">Section 16</a>)</span> allocates the necessary extension code points and an EKU OID for ECHConfig signing. Finally, Appendix A provides an example of a DNS record and a TLS handshake carrying an ECH config update, and Appendix B offers a deployment checklist for implementers.<a href="#section-3-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="wire-formats">
<section id="section-4">
      <h2 id="name-design-details-and-wire-for">
<a href="#section-4" class="section-number selfRef">4. </a><a href="#name-design-details-and-wire-for" class="section-name selfRef">Design Details and Wire Formats</a>
      </h2>
<p id="section-4-1">This section specifies the new extensions and data structures in detail. All multi-byte values are in network byte order (big-endian). The syntax uses the TLS presentation language from <span>[<a href="#RFC8446" class="cite xref">RFC8446</a>]</span>.<a href="#section-4-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="echconfig-metadata-echupdateauth-echconfig-extension">
<section id="section-5">
      <h2 id="name-echconfig-metadata-ech_upda">
<a href="#section-5" class="section-number selfRef">5. </a><a href="#name-echconfig-metadata-ech_upda" class="section-name selfRef">ECHConfig Metadata: <code>ech_update_auth</code> (ECHConfig extension)</a>
      </h2>
<p id="section-5-1">The <code>ech_update_auth</code> information is carried as an ECHConfig extension inside the ECHConfig structure. The ECH specification <span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span> allows ECHConfigContents to include extensions identified by a 16-bit type. This document defines a new ECHConfigExtensionType (<code>ech_update_auth</code>) with a suggested code point TBD1 (to be assigned from the "ECH Config Extension Type" registry). When present, this metadata advertises how the server will authenticate future updates to this ECHConfig (e.g., methods and pins). The actual authenticated update is conveyed in TLS via the <code>ech_config_update</code> extension (see the following section) and not via <code>ech_update_auth</code>.<a href="#section-5-1" class="pilcrow">¶</a></p>
<p id="section-5-2">The <code>ech_update_auth</code> extension data has the following structure:<a href="#section-5-2" class="pilcrow">¶</a></p>
<p id="section-5-3"><code>
enum { none(0), rpk(1), pkix(2), dnssec(4), reserved(8), (255) } ECHUpdateAuthMethodFlags;
// Values of ECHUpdateAuthMethodFlags are bit flags that can be ORed.
// e.g., a value of 3 (binary 0011) indicates support for both rpk (1) and pkix (2).
opaque SPKIHash&lt;0..255&gt;; // SHA-256 hash of an SPKI (SubjectPublicKeyInfo)
struct {
uint8 methods; // Bitwise OR of one or more ECHUpdateAuthMethodFlags
SPKIHash trusted_keys&lt;0..255&gt;;
} ECHUpdateAuth;
</code><a href="#section-5-3" class="pilcrow">¶</a></p>
<p id="section-5-4"><strong><code>methods</code></strong>: A bitmask indicating which update authentication methods the server supports for this ECH configuration. The bits correspond to: <code>0x01</code> = RPK (Raw Public Key via SPKI pin), <code>0x02</code> = PKIX (Certificate-based), <code>0x04</code> = DNSSEC, and <code>0x08</code> = (reserved for future use, see Section <span><a href="#reserved-nope" class="internal xref">Reserved Code Points</a> (<a href="#reserved-nope" class="auto internal xref">Section 19</a>)</span>). Bits beyond <code>0x08</code> are currently unassigned and MUST be zero. A client MUST ignore any value of <code>methods</code> that contains bits it does not recognize, except that it MUST NOT accept an update using a method it does not understand or did not agree to.<a href="#section-5-4" class="pilcrow">¶</a></p>
<p id="section-5-5"><strong><code>trusted_keys</code></strong>: A vector of hashes of public keys (each hash is 32 bytes for SHA-256, defined below). This list is used with the RPK method. Each element is the SHA-256 digest of a DER-encoded SubjectPublicKeyInfo (SPKI) of a key that is authorized to sign updates for this ECHConfig. The keys corresponding to these hashes are not further restricted by this specification (for instance, they need not correspond to the key in the current ECHConfig itself; they are separate keys chosen by the server operator for signing updates). The list may be empty if the RPK method is not used or if no keys are pinned (e.g., if only PKIX or DNSSEC methods are supported). If the <code>methods</code> bitmask includes the <code>rpk(1)</code> bit, then the <code>trusted_keys</code> vector MUST contain at least one SPKI hash. If the <code>rpk</code> bit is not set, <code>trusted_keys</code> MUST be zero-length (i.e., no RPK pins are advertised). There is no significance to the ordering of hashes in the list.<a href="#section-5-5" class="pilcrow">¶</a></p>
<p id="section-5-6">The SPKI hash function is SHA-256. The rationale for using a hash rather than the full SPKI is to keep the extension compact in DNS and on the wire, and to avoid exposing full public keys in the clear (though in many cases these public keys may correspond to certificates or other material that could be observable elsewhere). Using a hash also allows flexibility in key representation (the server can use any key type supported by the client's cryptographic libraries, as long as the client can verify a signature from it; the hash binds the key identity without needing new TLS code points for each algorithm here). The drawback is that hash collisions or second-preimage attacks on SHA-256 could undermine the pin – this is considered cryptographically infeasible at the time of writing.<a href="#section-5-6" class="pilcrow">¶</a></p>
<p id="section-5-7"><strong>Client behavior:</strong> When a client obtains an ECHConfig that contains an <code>ech_update_auth</code> extension, it SHOULD store this information along with the configuration. If the client subsequently uses this ECHConfig to initiate a connection, it will include in its ClientHello an extension indicating which of the methods it can process (see next section). If the client does not support any of the methods advertised, it simply will not include the support extension and will treat the ECHConfig as non-updatable in-band (the server might still rely on out-of-band update via DNS or others in such a case).<a href="#section-5-7" class="pilcrow">¶</a></p>
<p id="section-5-8">If an ECHConfig does not include <code>ech_update_auth</code>, the in-band update mechanism defined here is not used for that configuration. (A client MUST NOT send the support extension if the chosen ECHConfig has no update authentication data, since there would be nothing to agree on.)<a href="#section-5-8" class="pilcrow">¶</a></p>
<p id="section-5-9"><strong>Server behavior:</strong> A server that wishes to allow in-band updates MUST include <code>ech_update_auth</code> in the ECHConfig it publishes via DNS or other means. A server SHOULD set the <code>methods</code> bits to all methods it is willing to use, even if some are preferred over others; it can make the final choice of method when sending an update. The server MUST ensure that it actually has the capability to perform the indicated methods:
- If <code>rpk</code> bit is set, the server needs a signing key whose SPKI hash is in <code>trusted_keys</code>. (It may have multiple keys for rotation; all keys that might sign an update before the next ECHConfig change should be listed. Pins can be added or removed by generating a new ECHConfig with an updated list and distributing it out-of-band or via an update.)
- If <code>pkix</code> bit is set, the server must have a valid certificate (and chain) for the public name with the ECH config signing EKU (Section <span><a href="#iana" class="internal xref">IANA Considerations</a> (<a href="#iana" class="auto internal xref">Section 16</a>)</span> defines the EKU) available at runtime to use for signing. The certificate's public key algorithm dictates what signature algorithms are possible.
- If <code>dnssec</code> bit is set, the server must have access to DNSSEC signing infrastructure for the zone (or a way to obtain fresh DNS records). In practice, the server might simply fetch its own DNS record and include the proof if it knows the zone is signed and it has the ability to get the RRSIG and DNSKEY; or an operator might provision a service to provide the needed DNSSEC blobs. The specifics are out of scope of this document, but the server should only set this bit if it can produce a timely proof. (Including stale or incorrect DNSSEC data in an update will cause clients to ignore the update.)<a href="#section-5-9" class="pilcrow">¶</a></p>
</section>
</div>
<div id="clienthello-extension-for-update-method-support">
<section id="section-6">
      <h2 id="name-clienthello-extension-for-u">
<a href="#section-6" class="section-number selfRef">6. </a><a href="#name-clienthello-extension-for-u" class="section-name selfRef">ClientHello Extension for Update Method Support</a>
      </h2>
<p id="section-6-1">A new TLS extension type is defined for the client to indicate support for authenticated ECH config updates: <code>encrypted_client_hello_update_support</code> (name TBA). This is a <strong>ClientHello</strong> extension (it is not meaningful in ServerHello). We suggest a code point of TBD2 for this extension (to be assigned from the TLS ExtensionType registry). The extension data in the ClientHello is:<a href="#section-6-1" class="pilcrow">¶</a></p>
<p id="section-6-2">struct {
uint8 supported_methods; // Bitmask using ECHUpdateAuthMethodFlags
} ECHConfigUpdateSupport;<a href="#section-6-2" class="pilcrow">¶</a></p>
<p id="section-6-3"><strong>Contents:</strong> <code>supported_methods</code> is a single byte whose bits indicate the authentication methods the client can validate, using the same flag values as described for <code>ECHUpdateAuthMethodFlags</code> above (RPK=0x01, PKIX=0x02, DNSSEC=0x04). The client MUST NOT set any bits to 1 that were not present in the <code>methods</code> field of the ECHConfig it is using for this connection. In other words, this is an intersection of the server's advertised methods and the client's capabilities. If the client has no prior ECHConfig (e.g., in an opportunistic scenario where it is probing for ECH support via a GREASE extension<span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span>), it SHOULD NOT send this extension, since it does not know any server preferences. If the client has a cached ECHConfig but it contained no <code>ech_update_auth</code> extension (meaning the server does not support this update mechanism), the client MUST NOT send this extension.<a href="#section-6-3" class="pilcrow">¶</a></p>
<p id="section-6-4">When a client offers ECH (i.e., sends the "encrypted_client_hello" extension in ClientHelloOuter as defined in <span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span>), it SHOULD include the <code>ECHConfigUpdateSupport</code> extension in the <strong>outer</strong> ClientHello (ClientHelloOuter), not in the inner. This ensures that even if the server cannot decrypt the ClientHelloInner (due to an unknown or outdated ECHConfig), it can still see the client's support for updates in the outer handshake. If ECH is accepted, the server will also be able to see the outer extension (since it receives the outer ClientHello as well, even though it primarily processes the inner one for handshake purposes). Including it in the inner ClientHelloInner is unnecessary and not recommended, to avoid ambiguity. Clients MUST NOT include the extension in both inner and outer; they SHOULD include it only in the outer ClientHello in an ECH trial handshake. (If a future version of ECH allows encrypted client indications of update support, this recommendation might be revisited, but in the current design outer inclusion is sufficient.)<a href="#section-6-4" class="pilcrow">¶</a></p>
<p id="section-6-5">If a client is not offering ECH at all (for instance, connecting to a host for which it has no ECHConfig), it typically would not include this extension. However, an advanced client implementation MAY include <code>ECHConfigUpdateSupport</code> even without an ECH extension, as a way to indicate "I support in-band ECH config updates if you (server) have one to offer." This could be useful for opportunistic bootstrapping: a server receiving such an extension from a client that did not use ECH might choose to respond with an <code>ech_config_update</code> in EncryptedExtensions (using PKIX or DNSSEC method) to supply the client with an ECHConfig for future use. Such behavior is OPTIONAL. Clients who send update support without offering ECH should take care that the <code>supported_methods</code> value is based on some policy (e.g., their global capabilities or expected server's capabilities). In general, this usage is experimental and not mandated by this specification, but it is left possible for future expansion.<a href="#section-6-5" class="pilcrow">¶</a></p>
<p id="section-6-6"><strong>Server handling of client's extension:</strong> If the server receives a ClientHello (outer) containing the <code>ECHConfigUpdateSupport</code> extension and the server has a new ECHConfigList that it wishes to provide, it SHOULD decide on an authentication method as follows:
- The server MUST pick one method that is among those indicated by the client and also allowed by the current ECHConfig's <code>ech_update_auth.methods</code>. (For example, if the server's ECHConfig advertises methods = {RPK, PKIX}, and the client indicates support for {PKIX, DNSSEC}, the intersection is {PKIX} – the server should use PKIX in this case. If no intersection exists, the server must not send an update extension.)
- The server SHOULD prefer the method that it considers most secure or appropriate for the client. The relative preference may vary by implementation or policy. For instance, if DNSSEC is available and the client supports it, the server might choose DNSSEC because it leverages global trust anchors and avoids custom certificates or pins. Alternatively, a server might prefer RPK if it has an established pin with the client (for example, in a long-running deployment where clients have cached the pin and the operator wants to avoid CA or DNS dependencies).
- If multiple methods are equally acceptable, the server can choose any. This specification does not impose a strict preference, but for consistency, an implementation might define an order (e.g., DNSSEC &gt; PKIX &gt; RPK, or vice versa). All things being equal, using a method that does not require transmitting large certificates or multiple DNS records might be more efficient (RPK signatures are small, whereas DNSSEC proofs can be larger; PKIX includes a certificate chain which can also be large). Servers can take message size into account if fragmentation or handshake size is a concern.<a href="#section-6-6" class="pilcrow">¶</a></p>
<p id="section-6-7">Once the server selects a method, it prepares the <code>ech_config_update</code> extension to send, as described next.<a href="#section-6-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="tls-encryptedextension-echconfigupdate">
<section id="section-7">
      <h2 id="name-tls-encryptedextension-ech_">
<a href="#section-7" class="section-number selfRef">7. </a><a href="#name-tls-encryptedextension-ech_" class="section-name selfRef">TLS EncryptedExtension: <code>ech_config_update</code></a>
      </h2>
<p id="section-7-1">We define a new extension type <code>ech_config_update</code> (with code point TBD3) which is used by the server in the EncryptedExtensions message. The server MUST NOT send this extension unless the handshake is a TLS 1.3 (or higher) handshake where the client indicated support via <code>ECHConfigUpdateSupport</code> and the server is configured with an updated ECHConfigList to provide. If those conditions are met, the server MAY send the extension. There is no separate signal in the ServerHello; it appears only in EncryptedExtensions. (Presence or absence of this extension does not alter the TLS handshake flow for key agreement or certificate exchange, except as noted for fallback in Section <span><a href="#state-machine" class="internal xref">State Machine Impact</a> (<a href="#state-machine" class="auto internal xref">Section 17</a>)</span>.)<a href="#section-7-1" class="pilcrow">¶</a></p>
<p id="section-7-2">The extension data for <code>ech_config_update</code> is structured as follows:<a href="#section-7-2" class="pilcrow">¶</a></p>
<p id="section-7-3">enum { method_rpk(1), method_pkix(2), method_dnssec(3), (255) } ECHUpdateMethodType;
// These values are distinct from the bit flags above; they identify the specific method used in this message. struct {
ECHUpdateMethodType method;
opaque ech_config_list&lt;1..65535&gt;;
select (ECHUpdateMethodType) {
case method_rpk:
SignatureObject signature;
case method_pkix:
CertificateEntry cert_chain&lt;1..65535&gt;;
// CertificateEntry as defined in RFC8446, containing at least a leaf certificate
// (and possibly intermediates), followed by a SignatureObject signature.
case method_dnssec:
DNSSECUpdateProof dns_proof;
} auth;
} ECHConfigUpdate;<a href="#section-7-3" class="pilcrow">¶</a></p>
<p id="section-7-4"><strong><code>method</code></strong>: An enumerated value indicating which authentication method is used for this update. The values correspond to the methods defined earlier, but note that they are distinct from the bitmask used in <code>ECHUpdateAuthMethodFlags</code>. This field is a one-byte code: <code>1</code> for RPK, <code>2</code> for PKIX, <code>3</code> for DNSSEC. (Future methods may be assigned higher numbers; the 0 value is reserved and not used.) The server MUST set this to the method it chose based on the client's support and its own policy.<a href="#section-7-4" class="pilcrow">¶</a></p>
<p id="section-7-5"><strong><code>ech_config_list</code></strong>: This is the new ECHConfigList that the server wishes the client to use. It is encoded exactly as it would be in the DNS SVCB <code>ech</code> parameter or in the HTTPSSVC DNS record: a two-byte length followed by the concatenation of one or more ECHConfig structures (each of which has its internal length and version etc.). The client will parse this according to the ECH specification. The server MUST ensure that this list is compatible with the client's advertised ECH capabilities (for example, if the client only supports ECH version 0xfe0d and X25519 KEM, the server should include a config that matches those or the client will ignore it). In practice, the new ECHConfigList might have an updated <code>config_id</code> or a completely new public key (indicating a key rotation), or it might contain multiple entries (perhaps one for a new version of ECH if introduced, and one for backward compatibility). The server could also use this to distribute multiple public names or multiple sets of cryptographic parameters, but usually the list will contain one primary config. <strong>This field is the core data being delivered; the rest of the structure is about authenticating this field.</strong><a href="#section-7-5" class="pilcrow">¶</a></p>
<p id="section-7-6"><strong><code>auth</code> union</strong>: This part carries the proof or signature. It is a variant that depends on the <code>method</code> chosen:<a href="#section-7-6" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7-7.1">
          <p id="section-7-7.1.1"><strong>Raw Public Key (RPK) (method_rpk)</strong>: The <code>auth</code> field contains a <code>SignatureObject</code> named <code>signature</code>. We define <code>SignatureObject</code> in a similar way to other TLS structures:<a href="#section-7-7.1.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-7-8"><code>
struct {
SignatureScheme algorithm;
opaque signature&lt;0..2^16-1&gt;;
} SignatureObject;
</code><a href="#section-7-8" class="pilcrow">¶</a></p>
<p id="section-7-9">The data covered by the signature is defined as:<a href="#section-7-9" class="pilcrow">¶</a></p>
<p id="section-7-10"><code>
SignatureInput ::= HMAC( SHA256, current_time || context_string, 32) || ech_config_list
</code><a href="#section-7-10" class="pilcrow">¶</a></p>
<p id="section-7-11">The purpose of structuring it this way is to embed a validity window without relying on signer clocks to exactly match verifier clocks, and to tie the signature to usage in TLS ECH context. We define <code>current_time</code> as an 8-byte value representing the POSIX time (Unix epoch) in seconds at the moment of signature creation, encoded in network byte order. We define <code>context_string</code> as the ASCII string <code>"TLS_ECH_UPDATE"</code> (without quotes). The HMAC key and output are used as a way to include the time in the signature in a fixed-length, cryptographically mixed form. Specifically:<a href="#section-7-11" class="pilcrow">¶</a></p>
<p id="section-7-12"><code>
context_key = 0x00..00 (32 bytes of zero)
time_hmac = HMAC( SHA256, key = context_key, data = (current_time || context_string) )
</code><a href="#section-7-12" class="pilcrow">¶</a></p>
<p id="section-7-13">The <code>time_hmac</code> serves as a non-forgeable timestamp (an attacker cannot easily find a different time value that produces the same HMAC, assuming SHA256's strength). The server SHOULD set <code>current_time</code> to its current Unix time. The client, upon verifying the signature, will extract the first 32 bytes of the signed data (which is the HMAC output) and treat that as the declared time of signature. It will recompute the HMAC with its own view of time for a small number of candidate seconds around the current time to find a match (since clocks might not be perfectly synchronized). Specifically, the client can try current_time ± a fudge factor (e.g., ±5 minutes) to see if any produce the exact 32-byte value. If one matches, then the signature's time is accepted. If none match, the signature may be stale or from the future, and the client should consider it invalid (or, at its discretion, it MAY accept if within some policy window, but the expectation is that signatures carry their own expiration).<a href="#section-7-13" class="pilcrow">¶</a></p>
<p id="section-7-14">This design means the signature covers:
 - the ECHConfigList bytes (ensuring integrity and binding to the specific new config),
 - a time value (to prevent replay of an old update long after it was issued), and
 - a context string (to avoid any cross-protocol or cross-context replay; using "TLS_ECH_UPDATE" ensures this signature is specific to ECH updates in TLS).<a href="#section-7-14" class="pilcrow">¶</a></p>
<p id="section-7-15">An alternative design would be to include explicit fields like not_before and not_after in the structure; using HMAC on a timestamp is more compact on the wire and leverages the security of the signature itself to protect the time value. The zero key HMAC is essentially just SHA256 of the data, since:<a href="#section-7-15" class="pilcrow">¶</a></p>
<p id="section-7-16"><code>
HMAC_key(0) with data ≈ H(K ⊕ opad || H(K ⊕ ipad || data))
</code><a href="#section-7-16" class="pilcrow">¶</a></p>
<p id="section-7-17">with K zero likely simplifies, but we keep it conceptually as HMAC for clarity. (We could also just take:<a href="#section-7-17" class="pilcrow">¶</a></p>
<p id="section-7-18"><code>
SHA256(current_time || context_string)
</code><a href="#section-7-18" class="pilcrow">¶</a></p>
<p id="section-7-19">which might be sufficient. Implementations may treat it equivalently.)<a href="#section-7-19" class="pilcrow">¶</a></p>
<p id="section-7-20">Clients MUST check the freshness of the RPK signature. They SHOULD reject an update if the time indicated by the signature input is too far in the past or future. For example, a client might require that <code>current_time</code> in the signature is no more than 1 hour ahead of its own clock and not more than (say) 7 days behind. These limits are not fixed by this spec, but guidance is that because ECH keys are expected to rotate relatively infrequently (order of days or weeks), a signature older than the typical rotation interval might be suspicious. Conversely, a signature with a future timestamp indicates either clock skew or an attacker trying to post-date a signature to extend its validity; clients may have a small grace for clock differences but should not accept a far-future time.<a href="#section-7-20" class="pilcrow">¶</a></p>
<p id="section-7-21">If a client's clock is not reliable (e.g., a client without a real-time clock or that hasn't synchronized time), it MAY choose to skip time-based checks or use only relative measures (like how long since it first saw the update). However, such scenarios are out of scope; we assume clients have notion of current time for validation.<a href="#section-7-21" class="pilcrow">¶</a></p>
<p id="section-7-22"><strong>Note:</strong> The signature is computed over the raw concatenation of HMAC output and ECHConfigList. This means the signer needs to first compute the time HMAC, prepend it to the ECHConfigList bytes, and then sign the whole thing using the chosen signature scheme and its private key. The client will perform the inverse: given the signature, try to verify it with each candidate public key (whose hash matches one in <code>trusted_keys</code>). For each key, the client obtains the signature scheme (the algorithm field) from the SignatureObject, ensures it's compatible (e.g., the scheme matches the key type and is one the client considers secure), then verifies the signature on the concatenation of (<code>HMAC || ech_config_list</code>). If verification passes, it then parses the first 32 bytes of that concatenation as the HMAC of time and context, and proceeds with the freshness check as described. Only if all these steps succeed does the RPK update authenticate.<a href="#section-7-22" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7-23.1">
          <p id="section-7-23.1.1"><strong>PKIX (method_pkix)</strong>: For this method, the <code>auth</code> field contains two components:<a href="#section-7-23.1.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7-23.1.2.1">
              <p id="section-7-23.1.2.1.1"><code>cert_chain</code> – This is a CertificateEntry vector as defined in TLS 1.3 RFC8446, Section 4.4.2 carrying the server's certificate chain. The server MUST include at least the end-entity (leaf) certificate which has the public key used to sign the update, and SHOULD include any intermediate CA certificates needed for validation (except those presumably known to the client, like root certificates). The format is essentially the same as in a Certificate handshake message: each CertificateEntry contains a length and the ASN.1 certificate. (The <code>cert_chain</code> here is conceptually the same as sending the certificate in TLS handshake, but it is delivered inside this extension instead of the main Certificate message. This does not affect the actual handshake's authentication of the connection, which might be using a different certificate for the origin or public name.)<a href="#section-7-23.1.2.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-7-23.1.2.2">
              <p id="section-7-23.1.2.2.1">After the certificate entries, the server sends a digital signature over the update, similar to the structure in RPK. We reuse the <code>SignatureObject</code> structure:<a href="#section-7-23.1.2.2.1" class="pilcrow">¶</a></p>
</li>
          </ul>
</li>
      </ul>
<p id="section-7-24">The signature is computed with the private key corresponding to the leaf certificate included. The data to be signed is defined differently in this case to avoid confusion with the certificate's own handshake signature. We define the signed data as:<a href="#section-7-24" class="pilcrow">¶</a></p>
<p id="section-7-25"><code>
context_string = "TLS_ECH_UPDATE_PKIX"
signed_data = context_string || 0x00 || ech_config_list
</code><a href="#section-7-25" class="pilcrow">¶</a></p>
<p id="section-7-26">Here, the context string "TLS_ECH_UPDATE_PKIX" (ASCII, without quotes) followed by a single 0x00 byte serves as a distinctive prefix, to ensure this signature is not mistaken for some other usage (and that an attacker cannot trick a client into accepting a signature that might have been meant for another purpose). The byte 0x00 is just a separator (in case context string concatenation might ever collide with data; not strictly necessary but adds clarity).<a href="#section-7-26" class="pilcrow">¶</a></p>
<p id="section-7-27">The server signs <code>signed_data</code> using its certificate's private key and a signature scheme allowed by that certificate (and presumably by TLS). For example, if the certificate's public key is ECDSA P-256, it might use ecdsa_secp256r1_sha256; if RSA, rsa_pss_sha256, etc. The chosen SignatureScheme is indicated in the SignatureObject.<a href="#section-7-27" class="pilcrow">¶</a></p>
<p id="section-7-28">The client, upon receiving this, will:
 - Verify the certificate chain (chain building, signature verification, expiration check, and that the leaf certificate is valid for the <strong>public_name</strong> of the ECHConfig). The public name used here is the one from the <em>old/current</em> ECHConfig that the client used for this connection. Since the ECHConfigList update presumably corresponds to the same server identity, the certificate must be for that public name. This binds the update to an entity that is authoritative for that name via Web PKI trust. Additionally, the client MUST check that the leaf certificate includes the Extended Key Usage (EKU) for "ECH config signing" (OID to be assigned, see Section <span><a href="#iana" class="internal xref">IANA Considerations</a> (<a href="#iana" class="auto internal xref">Section 16</a>)</span>). If the EKU is missing or not the expected value, the client MUST reject the update (even if the certificate might be valid for normal TLS server authentication; the presence of the special EKU indicates explicit authorization for signing ECH configs, to prevent misuse of an unrelated certificate).
 - If the certificate chain is trusted and the certificate has the proper EKU and name, the client then verifies the signature using the leaf certificate's public key over the <code>signed_data</code> constructed as above (with the context string and the provided <code>ech_config_list</code>). If the signature is valid, then the update is authenticated. (We do not include a timestamp in the signed data for PKIX; the validity of the update is tied to the certificate's validity period and revocation status. Since a public CA-issued certificate can be revoked or expired, clients might rely on normal PKI mechanisms to decide if an update is still acceptable. For example, if the certificate expired last week, a client might reject an update signed with it unless it was received before expiry. However, detailing such timing is complex; it is RECOMMENDED that servers rotate the ECH signing certificate well before expiration and that clients not accept very old signatures. In practice, PKIX gives a fairly long-lived credential; this is acceptable because it's anchored in CA trust with revocation available. If more precise lifetime control is desired, use RPK or DNSSEC methods.)<a href="#section-7-28" class="pilcrow">¶</a></p>
<p id="section-7-29">It's worth noting that the PKIX method effectively piggybacks on the Web PKI. If the server is the one terminating TLS connections, it could reuse its existing certificate (for the public name) by having the CA include the ECH config signing EKU in it. However, operationally it might be better to have a separate certificate (perhaps even offline except when signing updates) to limit exposure. This spec permits either; the only requirements are the chain must validate and the EKU must be present.<a href="#section-7-29" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7-30.1">
          <p id="section-7-30.1.1"><strong>DNSSEC (method_dnssec)</strong>: In this method, the <code>auth</code> field contains a <code>DNSSECUpdateProof</code> structure. We define this structure to carry the necessary DNS records and signatures. The exact format can mirror a DNS message or be a simplified list of records. To keep it general, we define:<a href="#section-7-30.1.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-7-31"><code>
struct {
uint16 rrset_type;
opaque rrset_name&lt;1..255&gt;;
opaque rrset_wire&lt;1..65535&gt;;
opaque dnskey_record&lt;0..65535&gt;;
opaque ds_record&lt;0..65535&gt;;
} DNSSECUpdateProof;
</code><a href="#section-7-31" class="pilcrow">¶</a></p>
<p id="section-7-32">Here:
 - <code>rrset_type</code> is the DNS record type that conveys the ECH config. For example, this might be the type code for HTTPS (value 65) or SVCB (64), or possibly a TXT if someone uses a TXT record for ECH (not recommended, but included for flexibility). It's in network byte order.
 - <code>rrset_name</code> is the domain name of the record set, in DNS wire format (length-prefixed labels, ending in 0). For example, if the public name is <code>example.com</code>, the <code>rrset_name</code> might be <code>_echconfig.example.com.</code> or some agreed name under the domain where the ECH keys are published. By convention with SVCB/HTTPS, if the service is <code>example.com</code>, the HTTPS record might be at <code>_encrypted.example.com</code> or just <code>example.com</code> itself, depending on deployment. For simplicity, we will assume here that the ECH config is published at the same name as the public name or a well-known prefix of it. The exact name used should match whatever name was used to fetch the client's initial ECHConfig (so the client can correlate).
 - <code>rrset_wire</code> is the raw DNS RRset (all RRs of type = rrset_type for that name) concatenated in DNS wire format (typically, each RR: name (maybe compressed in normal DNS messages, but here it should be the full name since it's standalone), type, class, TTL, RDLENGTH, RDATA). This includes the RDATA which presumably has the encoded ECHConfigList. For example, for an HTTPS record, the RDATA will include the SvcParam "ech". The client will need to parse this to extract the ECHConfigList bytes and verify that it matches the <code>ech_config_list</code> field. To simplify, the server could include only the relevant part (like just the value of the ech param) to reduce size, but providing the full RRset allows verifying signatures properly (signatures cover name, type, class, etc., not just data).
 - <code>dnskey_record</code> is the DNSKEY RR (or RRset, if multiple) for the zone that signed the RRset above, in wire format. For instance, if the name is <code>example.com.</code>, this likely includes the DNSKEY of <code>example.com.</code> zone that corresponds to the key that made the RRSIG on rrset_wire. It could be multiple DNSKEYs (one zone may have multiple keys). This field can be empty if not needed (e.g., if the client already has the DNSKEY via other means or if the chain is short-circuited by some known trust anchor – but generally client will not have zone DNSKEY unless it's the root or TLD, so including it is safer).
 - <code>ds_record</code> is the DS record (or records) for that zone from the parent zone, also in wire format. E.g., the DS in the parent (like the com zone) for example.com's key. This may be empty if the zone is a trust anchor itself or if the server chooses to rely on the client having parent trust. Typically, to validate, the client needs a chain: example.com DNSKEY signed by example.com (self), RRSIG on the RRset by that DNSKEY, DS in com for example.com, com's DNSKEY (which might be known or included by another layer), etc. We do not necessarily include the entire chain to the root here; we assume clients have the root trust anchor and can obtain or cache intermediate (like TLD) DNSKEY via their own resolver or earlier steps. However, a complete chain could be provided if desired. In our structure we only provided one DNSKEY and one DS, which is sufficient to jump one step up. The client may have to fetch or have the next parent's DNSKEY (e.g., com's DNSKEY, which might be hard-coded or separately retrieved). This approach keeps the extension size moderate, but a fully self-contained proof might require multiple layers. For simplicity, we assume either the public name is not too deep in hierarchy or the client can handle obtaining some pieces.<a href="#section-7-32" class="pilcrow">¶</a></p>
<p id="section-7-33">The client's validation procedure:
 - Parse <code>rrset_wire</code> into the set of resource records. Verify that all records have the name matching <code>rrset_name</code> and type matching <code>rrset_type</code>. If any record in the set has a different name or type, the client SHOULD reject (to avoid confusion or attacks).
 - Extract the RRSIG record(s) for the RRset. (We did not explicitly include an RRSIG field in the structure; implicitly, the RRSIG for the RRset type might be included in <code>rrset_wire</code> if the server bundles it, or it could be separate. Perhaps we should have included RRSIG explicitly. We will assume that <code>rrset_wire</code> includes both the actual records and their RRSIG. In DNS, RRSIG is a separate RR type. It might have been clearer to separate them in structure, but including them together is fine as long as it's specified.)
 - Parse and extract the <code>ech_config_list</code> from the RRset: e.g., if it's an HTTPS RR, find the <code>ech</code> SvcParam value (base64 string) and decode it to get the bytes. Ensure that this exactly matches the <code>ech_config_list</code> bytes in the extension. If not, the update is invalid (the server included mismatched data).
 - Verify the DNSSEC signature: use the provided <code>dnskey_record</code> as the public key for the zone. Confirm the DNSKEY is valid (e.g., correct protocol, etc.) and corresponds to the DS (<code>ds_record</code>) from the parent if provided (i.e., compute the digest of DNSKEY and compare to DS, ensuring algorithm matches). If DS is provided, the client should verify it; if DS is not provided, the client might accept the DNSKEY if it is a known trust anchor or if out-of-band some trust is established (but normally, at least a DS should be given unless the zone is the root).
 - Check that the DNSKEY is duly authorized: either by DS or because it's the root (which the client trusts via RFC preset) or some known anchor. Assuming DS is present, verify the DS is signed by its parent (this may require the parent DNSKEY which is not provided here – we assume root and TLD keys are known or separately validated; this could be a caveat. In practice, including the entire chain (root DNSKEY, root RRSIG on DS of .com, etc.) would be needed for complete proof. This spec leaves it to the client's resolver or local trust to handle root and TLD, as fully packing them would be huge.)
 - Verify the RRSIG on the RRset using the DNSKEY. The RRSIG covers the RRset data (name, class, type, TTLs, and RDATA of all records). If valid and within its validity period (RRSIGs have inception and expiration times), then the RRset is authenticated.
 - Ensure the RRSIG's expiration is &gt;= current time (so the proof is fresh) and inception is &lt;= current time (so it's already valid). If the current time is outside the RRSIG validity window, the client MUST reject the update (stale or not yet valid proof).
 - If all checks pass, the DNSSEC proof is successful, and the client accepts the <code>ech_config_list</code> as authenticated.<a href="#section-7-33" class="pilcrow">¶</a></p>
<p id="section-7-34">The complexity of DNSSEC validation is well-known. This specification expects that if a client indicates support for DNSSEC method in the ClientHello, it has the necessary code or libraries to perform DNSSEC verification. Many validating DNS resolvers exist; a client might integrate one or use a stub resolver that can validate given a blob of data. It might also leverage existing DNSSEC trust (for example, if the client got the record via a local resolver with the AD flag, it might skip re-validation—but here the proof is delivered by the server, possibly because the client's resolver wasn't used or not trusted).<a href="#section-7-34" class="pilcrow">¶</a></p>
<p id="section-7-35">We emphasize that including only one layer (the child zone's DNSKEY and DS) may require the client to have the parent zone's DNSKEY from elsewhere. For instance, to validate <code>example.com</code>, we provide <code>example.com DNSKEY</code> and <code>com DS</code>. The client would need <code>com DNSKEY</code> (which could be known via a prior query or built-in if the client keeps an up-to-date list of TLD keys, or the server could have included it as <code>dnskey_record</code> for com and then DS for root, etc.). To fully avoid dependencies, a future iteration might allow a chain of DNSSEC records. However, to keep this draft simpler, we assume either that the client has a way to get the intermediate (like doing its own query to get com's DNSKEY which is signed by root) or that implementers will extend <code>DNSSECUpdateProof</code> to include multiple DNSKEYs/DS pairs for chain. In an IETF working group context, this could be refined, but for now, the main concept stands: the server provides enough DNSSEC data to prove authenticity of the ECHConfigList from DNS.<a href="#section-7-35" class="pilcrow">¶</a></p>
<p id="section-7-36"><strong>Wire image considerations:</strong> The <code>ech_config_update</code> extension appears in EncryptedExtensions, which is encrypted. It therefore does not add any cleartext bytes on the wire aside from maybe altering packet sizes slightly. The presence of the client's support extension in ClientHelloOuter is observable. This extension is quite small (1 byte of actual data plus overhead). An observer might infer that the client is ECH-aware and supports certain methods (e.g., if the byte is 0x04, perhaps only DNSSEC). However, since the mere presence of ECH (even GREASE) already signals ECH support, this is not a significant additional leak. If a client is concerned, it could omit advertising methods until it has a real ECHConfig from the server; but that is an implementation policy issue.<a href="#section-7-36" class="pilcrow">¶</a></p>
</section>
</div>
<div id="client-processing">
<section id="section-8">
      <h2 id="name-client-processing">
<a href="#section-8" class="section-number selfRef">8. </a><a href="#name-client-processing" class="section-name selfRef">Client Processing</a>
      </h2>
<p id="section-8-1">The client's extension (let us call it the "ECH Config Update Support" extension) carries a bitmask of methods (RPK, PKIX, DNSSEC) that the client supports <strong>and</strong> that were indicated by the server's published ECHConfig for this server. Clients MUST NOT indicate support for methods that were not present in the ECHConfig's <code>ech_update_auth</code> extension obtained via DNS or other source, to prevent downgraded security or ambiguous signaling.<a href="#section-8-1" class="pilcrow">¶</a></p>
<p id="section-8-2">In practice, a client that retrieves an ECHConfig (for example from a DNS HTTPS RR) will examine its <code>ech_update_auth</code> extension, take the intersection of the server-supported methods and the client's own capabilities or policy, and include an extension in the ClientHello listing that intersection. If the client does not have any ECHConfig for the server (e.g., a purely opportunistic attempt), it MAY omit the extension or include methods it generally supports (see Section <span><a href="#deployment-considerations" class="internal xref">Deployment Considerations</a> (<a href="#deployment-considerations" class="auto internal xref">Section 18</a>)</span>).<a href="#section-8-2" class="pilcrow">¶</a></p>
<p id="section-8-3">During the TLS handshake, if the server sees that the client can process authenticated updates, the server can send a new TLS 1.3 encrypted extension, <code>ech_config_update</code>, in its EncryptedExtensions message. (In TLS 1.3, the EncryptedExtensions message is sent immediately after ServerHello and is encrypted with handshake keys<span>[<a href="#RFC8446" class="cite xref">RFC8446</a>]</span>, so its contents are confidential and integrity-protected against network attackers.) The <code>ech_config_update</code> extension contains three fields: an authentication <code>method</code> (identifying which of the three methods is used for this update), an <code>ech_config_list</code> (the new ECHConfigList the server wants the client to use henceforth, encoded as a sequence of bytes exactly as would appear in the DNS SVCB or HTTPS RR<span>[<a href="#I-D.ietf-tls-svcb-ech" class="cite xref">I-D.ietf-tls-svcb-ech</a>]</span>), and a <code>signature_or_proof</code> field carrying the data necessary for the client to verify the update (this field's content depends on the chosen method and is detailed in Section <span><a href="#wire-formats" class="internal xref">Wire Format</a> (<a href="#wire-formats" class="auto internal xref">Section 4</a>)</span>). Because the extension is carried inside EncryptedExtensions, it benefits from the confidentiality of the handshake – an eavesdropper cannot observe the new ECH keys or even the fact that an update was delivered. (This contrasts with delivering ECH keys via DNS, which is generally observable unless DNS over TLS/HTTPS is used.)<a href="#section-8-3" class="pilcrow">¶</a></p>
<p id="section-8-4">Upon receiving an <code>ech_config_update</code> extension, the client will parse and verify it according to the method. A high-level summary of client processing is:<a href="#section-8-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-8-5.1">
          <p id="section-8-5.1.1">Check that the <code>method</code> field corresponds to one of the methods the client indicated and that the server's previously provided ECHConfig allowed. If not, the client MUST ignore the extension (and log an error if appropriate). For example, if a client indicated support for PKIX and DNSSEC only, and the server sends a method indicating RPK, the client will reject that update because it did not agree to RPK in this connection.<a href="#section-8-5.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-8-5.2">
          <p id="section-8-5.2.1">Validate the <code>ech_config_list</code> payload using the signature or proof.<a href="#section-8-5.2.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-8-5.2.2.1">
              <p id="section-8-5.2.2.1.1">If <code>method=RPK</code>, the client uses the list of SPKI hashes from the current ECHConfig's <code>ech_update_auth</code>. It attempts to verify the signature on the <code>ech_config_list</code> with the signer SPKI provided in the update object that matches a pin. The signature covers the ECHConfigList bytes and a validity interval, and possibly context such as the server's public name. If one of the public keys produces a valid signature that is within its declared time window, validation succeeds. If none do, validation fails.<a href="#section-8-5.2.2.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-8-5.2.2.2">
              <p id="section-8-5.2.2.2.1">If <code>method=PKIX</code>, the client verifies the certificate chain in <code>signature_or_proof</code> (ensuring the leaf certificate is valid, chains to a trusted root, covers the public name, and has the ECH config signing EKU). Then it uses the public key from the leaf certificate to verify the signature over the <code>ech_config_list</code> (and associated context/timestamp). If all checks pass, validation succeeds.<a href="#section-8-5.2.2.2.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-8-5.2.2.3">
              <p id="section-8-5.2.2.3.1">If <code>method=DNSSEC</code>, the client parses the provided DNS record set and uses the included DNSSEC records to verify authenticity. For example, the proof might include an <code>HTTPS</code> RRset for <code>_encrypted.client.example.com.</code> containing an <code>ech</code> parameter, accompanied by an RRSIG (signed by zone KSK/ZSK) and the DNSKEY record for the zone (and possibly DS record chain up to the root or a known trust anchor). The client performs standard DNSSEC validation<span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span> on this material. If validation succeeds and the RRset's content yields an ECHConfigList that matches <code>ech_config_list</code>, then the update is authentic.<a href="#section-8-5.2.2.3.1" class="pilcrow">¶</a></p>
</li>
          </ul>
</li>
        <li class="normal" id="section-8-5.3">
          <p id="section-8-5.3.1">If validation succeeds, the client installs or caches the new ECHConfigList for use in future connections to the server (or server's identity) as appropriate. If the update was received in a handshake that itself was a fallback (ECH retry) handshake, the client can immediately retry the connection using the new ECHConfig (see Section <span><a href="#state-machine" class="internal xref">Client State Machine and Retry</a> (<a href="#state-machine" class="auto internal xref">Section 17</a>)</span>). In general, clients SHOULD replace any older ECHConfig for that server with the new list (or merge as needed if multiple configurations are in use), and SHOULD respect any validity interval or expiration conveyed by the signature or proof (i.e., not using the config beyond the allowed time).<a href="#section-8-5.3.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-8-5.4">
          <p id="section-8-5.4.1">If validation fails, the client <strong>MUST ignore</strong> the <code>ech_config_list</code> update and continue the handshake without applying it. The client MUST NOT use a rejected update to initiate ECH in the future. A failure to verify does not, by itself, abort the TLS connection (since the handshake is presumably proceeding with the older configuration or in plaintext SNI mode), but it might indicate a misconfiguration or an attack, which the client may note in logs or telemetry. The security of the handshake is not compromised because the update is out-of-band for this connection's security context – it only affects future connections.<a href="#section-8-5.4.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-8-6">This framework is designed to be backward-compatible. If a client does not implement this draft, it will simply ignore the new <code>ech_config_update</code> extension from the server (since unknown TLS extensions in EncryptedExtensions are ignored as per TLS 1.3 rules). If a server does not implement this, it will ignore the client's support extension (if present), and continue with the handshake normally. Thus, incremental deployment is possible.
# Behavior Overview {#behavior}<a href="#section-8-6" class="pilcrow">¶</a></p>
<p id="section-8-7">This section describes how the above structures are used in practice during a TLS handshake, including error handling and interactions with ECH retry (fallback) behavior.<a href="#section-8-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="server-behavior">
<section id="section-9">
      <h2 id="name-server-behavior">
<a href="#section-9" class="section-number selfRef">9. </a><a href="#name-server-behavior" class="section-name selfRef">Server Behavior</a>
      </h2>
<p id="section-9-1"><strong>On initial connection (full handshake, client offered ECH):</strong> When a server receives a ClientHello that contains an "encrypted_client_hello" extension (i.e., the client is attempting ECH), it will process the ECH as per <span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span> to determine if it can decrypt the ClientHelloInner. At the same time, it should check for the presence of the <code>ECHConfigUpdateSupport</code> extension in the ClientHelloOuter. If the client did include that extension, and if the server has a newer ECHConfigList to send (for example, the server's current ECH key is about to expire or rotate, or perhaps the server always sends the same config via both DNS and in-band for redundancy), it proceeds to prepare an update.<a href="#section-9-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-9-2.1">
          <p id="section-9-2.1.1">If the server successfully decrypts the ClientHelloInner (ECH acceptance), it will complete the handshake using the inner ClientHello (which contains the true SNI etc.). The handshake will include EncryptedExtensions. The server MAY include the <code>ech_config_update</code> extension in EncryptedExtensions if conditions are met (client supports it and server has update). The decision algorithm was described in the overview: choose a method that the client supports and that the server is willing to use. If none, do nothing (no extension).<a href="#section-9-2.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-9-2.2">
          <p id="section-9-2.2.1">If the server fails to decrypt the ClientHelloInner (ECH rejection), it will follow the ECH spec procedures. ECH spec gives two main paths: HelloRetryRequest or proceeding with outer. According to the latest ECH draft, the server typically should send a HelloRetryRequest with <code>encrypted_client_hello</code> extension containing a retry confirmation and possibly indicate "ECH required" if it can provide new config. However, the base ECH spec left out sending the actual new configs in HRR for brevity, expecting DNS to handle distribution. With our mechanism, we can improve this:<a href="#section-9-2.2.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-9-2.3">
          <p id="section-9-2.3.1">The server, upon ECH failure, can either (a) send a HelloRetryRequest to trigger a second ClientHello attempt, or (b) proceed immediately with the outer handshake (presenting the public name's certificate and treating the connection as if ECH was not used, albeit not authenticated for the inner origin).<a href="#section-9-2.3.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-9-2.4">
          <p id="section-9-2.4.1">If the server chooses (a) HRR:<a href="#section-9-2.4.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-9-2.4.2.1">
              <p id="section-9-2.4.2.1.1">It MUST include the standard ECH retry confirmation as per <span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span> (to prove it saw the ECH).<a href="#section-9-2.4.2.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-9-2.4.2.2">
              <p id="section-9-2.4.2.2.1">Additionally, the server MAY include the <code>ech_config_update</code> extension in the HelloRetryRequest as well. However, standard TLS 1.3 does not normally allow EncryptedExtensions in HRR (HRR has its own extension space). We would have to allow <code>ech_config_update</code> as a HelloRetryRequest extension if we want to send the new config at the HRR stage. For now, let's assume we do <strong>not</strong> use <code>ech_config_update</code> in HRR (to avoid layering violations), and instead, the server will send the new config in the next EncryptedExtensions after the client retries. That means the client has to perform the retry with either the same old config or updated one from DNS. This is not ideal, so another approach:<a href="#section-9-2.4.2.2.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-9-2.4.2.3">
              <p id="section-9-2.4.2.3.1">Alternatively, we could piggyback on the HelloRetryRequest's existing design: since <span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span> currently does not send configs in HRR (only confirmation), a client in a pure <span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span> world might have to fetch a new config via DNS. With our mechanism, perhaps the best path for ECH failure is actually to not use HRR at all but to complete the handshake with outer (path b) and send the update in EncryptedExtensions. This way, the client gets the new config and can immediately reconnect with it.<a href="#section-9-2.4.2.3.1" class="pilcrow">¶</a></p>
</li>
          </ul>
</li>
        <li class="normal" id="section-9-2.5">
          <p id="section-9-2.5.1">If the server chooses (b) Outer handshake:<a href="#section-9-2.5.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-9-2.5.2.1">
              <p id="section-9-2.5.2.1.1">The server will proceed to send a ServerHello that ignores the inner ClientHello and uses the outer ClientHello (thus using the public name as SNI, etc.). The handshake will then carry on with EncryptedExtensions. In that EncryptedExtensions, the server SHOULD send <code>ech_config_update</code> (assuming client can support it) to give the client the correct ECHConfig for next time. This is essentially a more robust form of the "retry_configs" approach that ECH spec had, but now with authentication.<a href="#section-9-2.5.2.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-9-2.5.2.2">
              <p id="section-9-2.5.2.2.1">The server then completes the handshake with its certificate for the public name. The client will authenticate that certificate as per <span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span> Section 6.1.7<span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span>, <em>with the modification</em> that if the RPK method is in use and the presented certificate's public key matches one of the pinned <code>trusted_keys</code>, the client MAY accept the certificate even if it's not signed by a CA (see Section <span><a href="#public-name-auth" class="internal xref">Public Name Authentication</a> (<a href="#public-name-auth" class="auto internal xref">Section 11</a>)</span>). Otherwise, the certificate must be validated normally (which requires that the public name be something for which the server has a valid cert).<a href="#section-9-2.5.2.2.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-9-2.5.2.3">
              <p id="section-9-2.5.2.3.1">Note that in this outer handshake case, the server has effectively responded to an unknown ECH with a fallback connection that is not to be deemed secure for the origin (the client should treat it as unauthenticated for the real target, as ECH spec mandates<span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span>). The sole purpose of this connection is to convey the new ECHConfig. The client, after receiving it, will abort or close this connection (maybe immediately after handshake or after a dummy HTTP response) and reconnect using ECH properly.<a href="#section-9-2.5.2.3.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-9-2.5.2.4">
              <p id="section-9-2.5.2.4.1">In practice, the server might even send an "ech_required" alert at the end of handshake to signal the client to retry with ECH (ECH spec defines an "ech_required" alert for indicating the server insists on ECH). However, sending that alert might cut the connection before the client sees EncryptedExtensions? Actually, in TLS 1.3, if the server sends a fatal alert during handshake, the handshake ends. So better not to use an alert; instead, the client can infer from getting an <code>ech_config_update</code> that it should retry. We may define that if a client receives a valid update in a fallback handshake, it SHOULD initiate a new connection with ECH rather than continue using the plaintext one. The plaintext one can be dropped after perhaps completing the TLS handshake to avoid truncation issues. The client must not consider it authenticated for the inner origin anyway<span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span>.<a href="#section-9-2.5.2.4.1" class="pilcrow">¶</a></p>
</li>
          </ul>
</li>
      </ul>
<p id="section-9-3">Given the above, this document <strong>recommends</strong> that a server faced with an unknown ECHConfig (ECH rejection) use the outer-handshake-with-update approach rather than HelloRetryRequest, as it simplifies the update delivery. It is still compliant with <span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span>, since sending retry_configs in EncryptedExtensions is allowed<span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span>, and we are essentially doing that but in an authenticated way. The client in <span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span> spec was told to ignore those, but our client will not ignore because it understands the authentication.<a href="#section-9-3" class="pilcrow">¶</a></p>
<p id="section-9-4">Therefore:
- If ECH is rejected: The server SHOULD NOT send HelloRetryRequest with a fake confirmation only. Instead, it SHOULD continue with a ServerHello that uses the outer ClientHello. In the subsequent EncryptedExtensions, it SHOULD include <code>ech_config_update</code> (if possible given client support) to provide the correct configs. After this, it will send its Certificate (for public name) and so on. It MAY indicate in some way the expectation of retry (one approach could be a new extension or a specialized alert after handshake; however, simply providing the config is enough for a well-behaved client to retry on its own).
- If the server cannot continue with outer for some reason (e.g., it doesn't have a certificate even for the public name because it expected ECH always), it might have to use HelloRetryRequest. In such a case, it's outside this spec's main happy path. The server could perhaps include no config in HRR (since we didn't define how) and rely on DNS or client's cached pin to retrieve it. This is an edge scenario likely avoided by proper provisioning (server should have some certificate for the public name even if self-signed with pin).<a href="#section-9-4" class="pilcrow">¶</a></p>
<p id="section-9-5"><strong>In summary for server:</strong>
- Determine if sending update: if client has extension and server has new config (or wants to reinforce existing config's authenticity).
- Choose method, prepare ECHConfigUpdate structure.
- Include it in EncryptedExtensions (either on an accepted ECH handshake or on a fallback outer handshake).
- If on fallback outer handshake, optionally prepare to close connection after sending update (the server might even send a session ticket or just a message saying "please reconnect", but that's application level; not in TLS spec).
- Note: The server should not send <code>ech_config_update</code> if it doesn't see client support, or if it has no changes. It is possible for server to always send it anyway (with the same config as client used), acting as an affirmation. This is not harmful; a client will verify and see it's the same it already has. But to save bandwidth, it might only send when there's a difference or an upcoming rotation.<a href="#section-9-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="client-behavior">
<section id="section-10">
      <h2 id="name-client-behavior">
<a href="#section-10" class="section-number selfRef">10. </a><a href="#name-client-behavior" class="section-name selfRef">Client Behavior</a>
      </h2>
<p id="section-10-1">The client's operation can be broken into phases:<a href="#section-10-1" class="pilcrow">¶</a></p>
<p id="section-10-2"><strong>Before connection (config retrieval):</strong> The client obtains an ECHConfig for the server (via DNS SVCB/HTTPS RR, .well-known URI, or configuration). If that ECHConfig has <code>ech_update_auth</code>, the client notes the methods and any pinned keys. The client chooses a config to use (as per <span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span>, perhaps the highest version it supports). Then:
- If the chosen config has <code>ech_update_auth.methods</code> nonzero, the client will include an <code>ECHConfigUpdateSupport</code> extension in its ClientHelloOuter with <code>supported_methods</code> equal to (config.methods ∧ client_capabilities).
- If no such extension or if the config has none, the client does nothing extra.<a href="#section-10-2" class="pilcrow">¶</a></p>
<p id="section-10-3"><strong>During handshake:</strong>
- If the handshake succeeds using ECH (meaning server accepted ECH and the handshake proceeds normally with inner), the client will check EncryptedExtensions for <code>ech_config_update</code>.
- If present, the client processes it (parses as per structure). It must verify that the <code>method</code> in the extension was one of the bits it sent. If not, ignore (and optionally treat as an error).
- Then perform verification as per method:
  * <strong>RPK</strong>: Try each pinned SPKI (the client needs the actual public keys for those hashes. How does it get them? This is important: The client might not have stored the full public key, only the hash. We might need to adjust: either the initial config could include not just hash but maybe also the public key in some form? Or the server might include the public key in the signature structure?<a href="#section-10-3" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-10-4">
<pre>
Actually, since the pinned keys might not be the same as any TLS keys, the client doesn't automatically have the actual public key just from the hash. One idea: the server could include the public key with the signature to allow verification without out-of-band lookup, but that undermines some benefits of hashing (though it's encrypted in handshake, so maybe fine).
Alternatively, we require that the client somehow obtains the public key corresponding to the hash by some out-of-band means. Perhaps the `ech_update_auth` should have included the full public key? But that could bloat the DNS record or be redundant with a certificate maybe.

Possibly a simpler approach: Use the hash as identifier only, but assume that typically the pinned key might be the key in some certificate the client can get or the server's outer certificate key. For instance, PNMasq idea was that the public name certificate might have the pinned key. If so, the client can extract it from the certificate.
Another approach: have the server send a self-contained signature that includes the public key, e.g., if algorithm is Ed25519, server could send a raw Ed25519 public key and signature. But then how to trust that key? It was hashed in initial config though, so the client can check hash matches, so that could work: have the signature object in method_rpk include the public key of signer. That adds a bit overhead but ensures client can verify signature without needing an external key database. This was not explicitly included above, but we could say if using RPK, algorithm dictates the key (like for RSA/ECDSA, you could send a certificate, but then that's PKIX method. For RPK, keys might not have certs).

Perhaps simpler: in `SignatureObject`, we could allow carrying the public key. But SignatureScheme in TLS doesn't include carrying key.
Another route: The pinned keys could be exactly the public keys of the server's own certificate or something. But then that's basically a pinned certificate key – which is exactly PNMasq approach (the server's certificate used in outer handshake is pinned via hash in config). If that's done, then the client *does* have the public key (from the cert).
Actually, this lines up: if RPK method is used, maybe the intent is that the pinned SPKI is of the public name's TLS certificate (which might be self-signed or from a local CA). In that case, the client sees the certificate in the fallback handshake, checks its SPKI hash against the pin, and if matches, trusts it for the update signature too. The server could then sign the update using the same key, or skip signing and rely on certificate? But we decided to sign anyway. If using same key, the signature could even reuse the CertificateVerify from handshake? That's messy. Instead, server just signs separately. The client can get the public key from the certificate (which is transmitted anyway in handshake if fallback).

However, in a successful ECH handshake, there is no outer certificate transmitted (the handshake is encrypted, certificate is inner). The pinned key might not have been used in this handshake at all. So the client would have to either have cached it from a prior fallback or initial key distribution.
Possibly initial key distribution included a certificate? For example, in DNS, they could publish a SPKI hash of a key and also maybe a corresponding self-signed certificate via some channel. This is getting complex.

Perhaps we assume pinned keys are distributed out-of-band as well (like via the initial DNS if DNSSEC or via the .well-known JSON if used). The pinned key could be the same as the ECH config's HPKE key, but that's not a signing key for signatures (HPKE KEM keys likely not suitable for signatures).

Or pinned key might correspond to an actual known entity's key like the hidden service's real cert? That defeats anonymity if reused.

It's tricky. For now, we might say: if client cannot directly access the public key for a given hash, it can't verify. Implementations might choose to store actual keys along with hashes if they had them (e.g., if learned via a previous TLS handshake or provided by user).
We can add a recommendation: servers using RPK should ensure the client gets the public key at least once (like on initial contact via certificate or including it in some initial update with PKIX or DNSSEC).
Possibly initial config is via DNSSEC or PKIX (so authenticated), then it pins a key for future. That pinned key might not be used until rotation. So at rotation, the server will use it to sign, but the client doesn't have it. This is a bootstrap issue. If initial config had DNSSEC method, the client got it and sees a pin for future, but doesn't know actual key. The client can only check signature by trial among pins if it had keys. Without keys, hash is useless for verification except as identity if key is provided with signature.

Perhaps we should modify the RPK update structure to include the public key of the signer. That way, the client gets the key, checks its hash matches one in the trusted list, then uses it to verify. Yes, that solves it elegantly:
For method_rpk, let's say `SignatureObject` is extended:
```
struct {
   SignatureScheme algorithm;
   opaque public_key&lt;1..2^16-1&gt;;
   opaque signature&lt;0..2^16-1&gt;;
} SignatureObject;
```
The `public_key` field would carry the public key bytes (format depends on algorithm, e.g., for RSA it's the DER encoding of RSAPublicKey or SubjectPublicKeyInfo? For simplicity, perhaps a SubjectPublicKeyInfo structure DER-encoded).
If we do that, the pinned SPKI hash can be directly matched to the hash of this SPKI. If it matches, then we trust this key and use it to verify the signature. This removes the need for external retrieval.

We did not include this earlier. We can incorporate it now in text (not in code above since final answer given code earlier, but in explanation).
We can adjust in text: "If method=RPK, the signature object includes the signer's public key so the client can verify without prior knowledge." That should be fine.

We'll do that in text: define that the `SignatureObject.signature` covers the concatenation of context HMAC and ech_config_list, and the `SignatureObject` provided contains the algorithm and maybe also the public key (embedding the public key in signature algorithm field might not be standard, but we can piggyback in the structure).

For brevity, we might just state "the server MUST include the signing public key (in SPKI form) along with the signature if that key is not expected to be otherwise known to the client (e.g., in the certificate chain)."
This is not an on-the-wire defined structure in TLS normally, but we can define it here as part of extension data.
</pre><a href="#section-10-4" class="pilcrow">¶</a>
</div>
<ul class="normal">
<li class="normal" id="section-10-5.1">
          <p id="section-10-5.1.1">After verification success, client caches new config list.<a href="#section-10-5.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-10-5.2">
          <p id="section-10-5.2.1">If handshake was an outer fallback one (server rejected ECH and continued outer), the client now has the config. Per ECH spec, the client MUST NOT consider the connection authenticated for the actual origin<span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span>. The client SHOULD immediately retry a new connection using the new ECHConfig. Possibly it can drop the current connection (or, since TLS handshake succeeded, it could send a polite application-layer indication it's going away). But likely simpler: close connection. The application should not be given this connection for any sensitive data.<a href="#section-10-5.2.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-10-5.3">
          <p id="section-10-5.3.1">If handshake was inner (ECH succeeded), then the connection is already to the intended origin securely. The new config is just stored for next time. The client continues normally with this connection.<a href="#section-10-5.3.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-10-5.4">
          <p id="section-10-5.4.1">If the handshake completed without any <code>ech_config_update</code> extension, nothing changes; the client continues as normal. If the handshake was outer fallback, the client might then rely on DNS or something to get a config, or treat it as failure depending on policy. (In base ECH, one outer fallback is allowed, but if no update given, the client might query DNS again before retrying. <span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span> says clients may use info from fallback to avoid immediate repeat, but they might need DNS TTL etc. Our mechanism is meant to avoid that scenario by giving something.)<a href="#section-10-5.4.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-10-5.5">
          <p id="section-10-5.5.1">If <code>ech_config_update</code> was present but verification failed:<a href="#section-10-5.5.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-10-5.6">
          <p id="section-10-5.6.1">If it's an inner handshake scenario, the client ignores the update (the connection is still good to use since it was inner handshake with valid cert for real origin; just the update is discarded. The client might log or notify that the server's update was invalid).<a href="#section-10-5.6.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-10-5.7">
          <p id="section-10-5.7.1">If it's an outer handshake scenario (ECH rejected):<a href="#section-10-5.7.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-10-5.7.2.1">
              <p id="section-10-5.7.2.1.1">The client will not have a valid new config. At this point, continuing to use the outer connection is presumably not acceptable for the origin (assuming origin required ECH or at least that connection is suspect). The client could either:<a href="#section-10-5.7.2.1.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-10-5.7.2.1.2.1">
                  <p id="section-10-5.7.2.1.2.1.1">Treat it as a fatal error and close the connection (and maybe indicate failure to user or application).<a href="#section-10-5.7.2.1.2.1.1" class="pilcrow">¶</a></p>
</li>
                <li class="normal" id="section-10-5.7.2.1.2.2">
                  <p id="section-10-5.7.2.1.2.2.1">Or, if it still has some hope (like maybe it will attempt to fall back to no ECH for that origin, which leaks SNI but in case server just doesn't support ECH at all or attacker stripping?), that's outside our scope. Typically, if ECH was offered but failed and no valid retry config is obtained, it suggests either an attacker interfering or misconfiguration. ECH spec suggests not to automatically fall back to clear SNI, except possibly for certain policies. Many clients, for privacy, will fail connection rather than expose real SNI after offering ECH (especially if "ECH required" policy).<a href="#section-10-5.7.2.1.2.2.1" class="pilcrow">¶</a></p>
</li>
                <li class="normal" id="section-10-5.7.2.1.2.3">
                  <p id="section-10-5.7.2.1.2.3.1">So likely, the client should abort and maybe wait or try again later.<a href="#section-10-5.7.2.1.2.3.1" class="pilcrow">¶</a></p>
</li>
              </ul>
</li>
          </ul>
</li>
      </ul>
</section>
</div>
<div id="public-name-auth">
<section id="section-11">
      <h2 id="name-public-name-authentication-">
<a href="#section-11" class="section-number selfRef">11. </a><a href="#name-public-name-authentication-" class="section-name selfRef">Public Name Authentication for Retry</a>
      </h2>
<p id="section-11-1">As mentioned, one advantage of this framework is the ability to authenticate fallback connections via a pinned key rather than a CA-issued certificate. In the context of ECH, when a server rejects ECH and uses the outer ClientHello to continue, the client ordinarily must verify the server's certificate for the public name<span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span>. If the operator has used a unique public name (possibly one not even signed by a public CA), this would fail, making it impossible to deliver the new ECH config. To address this, we leverage pinned keys.<a href="#section-11-1" class="pilcrow">¶</a></p>
<p id="section-11-2">If the ECHConfig's <code>ech_update_auth</code> includes the RPK method, and the server chooses to use that method for updates, then the server can present a certificate in the outer handshake that is <strong>self-signed or issued by a private CA</strong>, as long as its public key matches one of the SPKI hashes in <code>trusted_keys</code>. The client, upon seeing the server's Certificate message during the outer handshake, will extract the SPKI of the leaf certificate. It computes the SHA-256 hash of that SPKI and checks if it is in the <code>trusted_keys</code> list from the ECHConfig. If it is, then the client MAY accept this certificate as proof of server identity for the public name <em>for the sole purpose of ECH retry</em>. In other words, the client can treat the outer handshake as being authenticated for the public name via the pin, even though the cert is not publicly trusted. This allows the handshake to complete without a PKI error. <strong>However</strong>, the client MUST still treat the connection as not authenticated for the actual hidden origin (it must not send application data thinking it's talking securely to the origin, since the outer cert isn't validated by conventional means)<span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span>. The only "authentication" achieved is that the server demonstrated knowledge of the private key corresponding to the pinned SPKI, which was advertised by the genuine server in the initial ECHConfig. This assures the client that the handshake is not intercepted by a third-party attacker (who wouldn't have the pinned key), assuming the initial config came securely.<a href="#section-11-2" class="pilcrow">¶</a></p>
<p id="section-11-3">In practice, this means:
- The client performs the certificate check in two layers on an outer handshake:<a href="#section-11-3" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-11-4">
<li id="section-11-4.1">
          <p id="section-11-4.1.1">It checks if the certificate is valid under PKIX for the public name. If yes, proceed (that's the PKIX method scenario).<a href="#section-11-4.1.1" class="pilcrow">¶</a></p>
</li>
        <li id="section-11-4.2">
          <p id="section-11-4.2.1">If PKIX validation fails, it then checks if any SPKI pin matches. If yes, and the server proved the pin (by completing the handshake with that cert, proving possession via the CertificateVerify), the client accepts the server's identity for public name on the basis of the pin. If neither PKIX nor pin matches, then the handshake is unauthenticated and must be aborted (or treated as completely insecure).
- If the client accepted via pin, it will then verify the <code>ech_config_update</code> using the signature which presumably also uses the same key (in RPK method, likely the server will sign the update with that same key; it should, otherwise the client would need another public key to verify signature which it may not have – hence it makes sense that the pinned key in many cases is also the key used to sign updates, meaning server's outer cert key = pinned key).
- After getting the new ECHConfig and validating signature, the client will open a new connection using ECH. The pinned-key authenticated connection is no longer needed and should be closed. Since it wasn't authenticated for the hidden origin, no sensitive data should have been transmitted over it (except maybe a benign signal or a generic error page if at all).<a href="#section-11-4.2.1" class="pilcrow">¶</a></p>
</li>
      </ol>
<p id="section-11-5">This approach is essentially an integration of the concept from the "Public Name Masquerade" proposal<span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span> (without naming it). It enables multiple public names and even one-time names because you don't need a CA-signed cert for each – a pinned key can cover them. The pin acts as a lightweight trust anchor specific to that ECH deployment.<a href="#section-11-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="privacy-considerations-in-mechanism">
<section id="section-12">
      <h2 id="name-privacy-considerations-in-m">
<a href="#section-12" class="section-number selfRef">12. </a><a href="#name-privacy-considerations-in-m" class="section-name selfRef">Privacy Considerations in Mechanism</a>
      </h2>
<p id="section-12-1">The design ensures that distribution of ECH configs does not significantly compromise privacy. The delivered <code>ech_config_list</code> is encrypted in the handshake (so on-path observers don't learn the new ECH keys or any info within). The client's support extension in ClientHelloOuter does reveal a bit of information: which methods the client supports (e.g., knowledge of DNSSEC, etc.). In most cases, this is not highly sensitive. It could potentially be used as a fingerprinting bit (distinguishing clients by their combination of support). To mitigate that, clients might choose to always indicate support for all methods they implement, rather than a subset, to reduce variability. Also, because this extension is only sent when offering ECH, the set of users is already somewhat privacy-conscious or using modern clients, which limits exposure.<a href="#section-12-1" class="pilcrow">¶</a></p>
<p id="section-12-2">By enabling the use of arbitrary public names (with pins or DNSSEC proofs), this mechanism can increase the size of the anonymity set for ECH. Servers could use unique or random public names for each connection or each client without worrying about CA issuance, as long as the DNS and pinning is managed, thus making it harder for observers to map public names to specific hidden origins<span>[<a href="#I-D.ietf-tls-esni" class="cite xref">I-D.ietf-tls-esni</a>]</span>. However, if unique names are used, a passive observer might still see patterns (like a particular client always gets a unique name, which could ironically become an identifier for that client across sessions if not done carefully). Operators should balance how they use this capability—e.g., maybe rotate public names per time period or group of clients to avoid one-to-one linkability.<a href="#section-12-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="example-exchange-informative">
<section id="section-13">
      <h2 id="name-example-exchange-informativ">
<a href="#section-13" class="section-number selfRef">13. </a><a href="#name-example-exchange-informativ" class="section-name selfRef">Example Exchange (Informative)</a>
      </h2>
<p id="section-13-1"><em>This section provides a non-normative example to illustrate the protocol.</em><a href="#section-13-1" class="pilcrow">¶</a></p>
<p id="section-13-2"><strong>DNS Example:</strong> Suppose <code>api.example.com</code> is a hidden origin behind ECH. The operator uses a public name <code>front.example.net</code> for ECH. They publish a DNS HTTPS record for <code>_encrypted.front.example.net.</code> containing an <code>ech</code> parameter:
_encrypted.front.example.net. 3600 IN HTTPS 1 . alpn="h2,h3" ech="...base64-encoded ECHConfigList..."
Included in that ECHConfigList is an <code>ech_update_auth</code> extension. Let's say the operator supports all three methods: they have a DNSSEC-signed zone, a certificate for <code>front.example.net</code>, and also want to use RPK pinning. They generate a signing key pair (Ed25519) and compute its SPKI hash. They include in <code>trusted_keys</code> that hash, and set methods bitmask = 0x07 (binary 111 = 1+2+4 for RPK, PKIX, DNSSEC). The client queries DNS (over DNSSEC or not). If the client is DNSSEC-aware, it validates the HTTPS RR and the ech value. If not, it at least gets the ECHConfigList bytes (without knowing if they were spoofed). Either way, it now has:
- The ECHConfig with public name "front.example.net", HPKE key, etc.
- The <code>ech_update_auth</code> saying methods=7 and a list with, say, one SPKI hash.<a href="#section-13-2" class="pilcrow">¶</a></p>
<p id="section-13-3">The client supports DNSSEC and PKIX but not implementing RPK? Actually, let's assume it supports all as well. It will include <code>supported_methods = 0x07</code> in ClientHelloOuter.<a href="#section-13-3" class="pilcrow">¶</a></p>
<p id="section-13-4"><strong>TLS Handshake:</strong> The client attempts to connect to <code>api.example.com</code> using ECH with the config. The outer ClientHello (to <code>front.example.net</code>) has "encrypted_client_hello" extension (outer) and "server_name" = "front.example.net", plus the <code>encrypted_client_hello_update_support</code> extension with value 0x07. The inner ClientHello carries SNI = "api.example.com".<a href="#section-13-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-13-5.1">
          <p id="section-13-5.1.1"><strong>Server behavior:</strong> The server (front-end) receives CHOuter with ECH. It decrypts using HPKE; suppose it succeeds (client had correct key). Now it sees CHInner (with "api.example.com"). It proceeds with ECH accepted. It sees the support extension (outer). Meanwhile, maybe the server knows it's about to rotate keys tomorrow, so it wants to send an update. It prepares a new ECHConfigList (maybe with a new key and config_id). It decides which method: since both it and client support all, the server chooses, e.g., <strong>PKIX</strong> for this update (maybe because it has a fresh certificate for <code>front.example.net</code> with EKU and wants to use the Web PKI trust).<a href="#section-13-5.1.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-13-5.1.2.1">
              <p id="section-13-5.1.2.1.1">The server's certificate for <code>front.example.net</code> is issued by a CA, and contains the EKU OID for ECH config signing.<a href="#section-13-5.1.2.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-13-5.1.2.2">
              <p id="section-13-5.1.2.2.1">The server forms the update: <code>method = 2 (PKIX)</code>, <code>ech_config_list = &lt;bytes of new config list&gt;</code>. It then takes its ECH signing certificate's private key and signs the data <code>("TLS_ECH_UPDATE_PKIX" || 0x00 || ech_config_list)</code> with (say) RSA-PSS or ECDSA. It includes in auth: the full certificate chain (leaf + intermediate) and the SignatureObject (algorithm and signature bytes).<a href="#section-13-5.1.2.2.1" class="pilcrow">¶</a></p>
</li>
          </ul>
</li>
        <li class="normal" id="section-13-5.2">
          <p id="section-13-5.2.1">The server continues the handshake: it sends ServerHello + EncryptedExtensions. In EncryptedExtensions, along with usual stuff (maybe ALPN, etc.), it adds the <code>ech_config_update</code> extension containing the structure above. Then it sends Certificate (for <strong>api.example.com</strong> now, since ECH succeeded, note this is a different cert for the hidden origin), CertificateVerify, Finished, etc.<a href="#section-13-5.2.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-13-5.3">
          <p id="section-13-5.3.1"><strong>Client processing:</strong> The client verifies ServerHello as usual (it sees that ECH was accepted via the "ech_acceptance_confirmation" mechanism in TLS-ECH). So it knows the connection is for <code>api.example.com</code> and will verify the origin's cert accordingly (which should be valid for <code>api.example.com</code>). Now it processes EncryptedExtensions and finds <code>ech_config_update</code>.<a href="#section-13-5.3.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-13-5.3.2.1">
              <p id="section-13-5.3.2.1.1">It sees <code>method=2 (pkix)</code>. It knows it supported that.<a href="#section-13-5.3.2.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-13-5.3.2.2">
              <p id="section-13-5.3.2.2.1">It extracts the certificate chain from the extension and the signature. It performs certificate validation: the leaf cert is for <code>front.example.net</code>, issued by e.g. Let's Encrypt, with EKU "ECH Config Signing". It chains to a trusted root. All good. Public key maybe an EC P-256.<a href="#section-13-5.3.2.2.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-13-5.3.2.3">
              <p id="section-13-5.3.2.3.1">It checks the EKU presence (to ensure this cert is allowed to sign ECH configs). OK.<a href="#section-13-5.3.2.3.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-13-5.3.2.4">
              <p id="section-13-5.3.2.4.1">Then it verifies the signature on data <code>"TLS_ECH_UPDATE_PKIX" || 0x00 || ech_config_list</code> using the leaf's public key and the algorithm (say ECDSA/SHA256) specified. Signature is valid.<a href="#section-13-5.3.2.4.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-13-5.3.2.5">
              <p id="section-13-5.3.2.5.1">Now it compares the new ECHConfigList with what it had. It's different (new key). It stores it in its cache for <code>front.example.net</code> (or for origins that were behind that).<a href="#section-13-5.3.2.5.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-13-5.3.2.6">
              <p id="section-13-5.3.2.6.1">The handshake continues; it verifies the server's Certificate for <code>api.example.com</code> (that's the inner cert in handshake, likely issued by a CA for the origin). That succeeds. Handshake finishes. Now the client has a secure connection to <code>api.example.com</code> (which it uses normally for HTTP, etc.) and it also has updated the ECH config for next time.<a href="#section-13-5.3.2.6.1" class="pilcrow">¶</a></p>
</li>
          </ul>
</li>
        <li class="normal" id="section-13-5.4">
          <p id="section-13-5.4.1">At the next hour, the server rotates keys. The client, having cached the new config, uses it and avoids any fallback.<a href="#section-13-5.4.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-13-6"><strong>Out-of-date or missing ECH configuration:</strong> A client might connect without offering ECH or with an incorrect key. An ECH deployment MUST NOT rely on fallback to non‑ECH. Instead, the server provides an authenticated update in EncryptedExtensions (e.g., RPK, PKIX, or DNSSEC) and the client then initiates a new connection using ECH. For example, the server can send <code>ech_config_update</code> with method RPK, including the signer SPKI and signature; the client hashes the SPKI to a pin, verifies the signature (including timestamp), installs the new config, closes the initial connection without sending sensitive data, and reconnects with ECH.<a href="#section-13-6" class="pilcrow">¶</a></p>
<p id="section-13-7">In this example, we saw a variety of uses of the mechanism.<a href="#section-13-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="security">
<section id="section-14">
      <h2 id="name-security-considerations">
<a href="#section-14" class="section-number selfRef">14. </a><a href="#name-security-considerations" class="section-name selfRef">Security Considerations</a>
      </h2>
<p id="section-14-1">The security of this mechanism rests on the authenticity of the <code>ech_config_update</code> messages and the initial trust in the first ECHConfig.<a href="#section-14-1" class="pilcrow">¶</a></p>
<p id="section-14-2"><strong>Initial Trust Bootstrap:</strong> The first ECHConfig that a client uses for a server must come from a trustworthy source; otherwise, an attacker could inject a malicious ECHConfig that, for example, pins the attacker's key in <code>trusted_keys</code>, enabling a sophisticated interception. Possible sources and their trust:
- DNS without DNSSEC: If a client obtains ECHConfig via a plaintext DNS and does not or cannot validate DNSSEC, an active attacker on path could feed it a fake ECHConfig with a malicious <code>ech_update_auth</code> (for instance, listing the attacker's own key in <code>trusted_keys</code>). The client would then connect with ECH (which the attacker can't decipher, but the attacker could cause ECH to fail by blocking server response, etc.), then on fallback the attacker (MITM) could present a certificate with their own key and sign a fake update. If the client were to accept that (because it was pinned), the attacker could trick the client into storing a bogus ECHConfig (perhaps one with a key the attacker knows). This is a serious attack if the initial config isn't authenticated. <strong>Mitigations:</strong> Clients that do not have a secure channel for initial ECHConfig SHOULD be cautious about accepting the RPK method. Specifically, if the initial ECHConfig is from an unauthenticated source, the client SHOULD prefer a PKIX or DNSSEC update method if available, and only use RPK if those are not offered. If RPK is the only method, the client could consider doing an additional check (for example, if the outer handshake uses a publicly invalid cert and pinned key, perhaps consult a trusted source or the user). Operationally, using DNSSEC or providing the initial config via HTTPS (with a valid cert) can prevent such attacks. In summary, RPK is strongest when the initial contact is protected (hence "trust on first use"—the first use needs some level of trust).
- DNSSEC: If the initial ECHConfig is obtained via DNSSEC-validated records (or through this mechanism's DNSSEC method from a server with an existing trust anchor, like the public web PKI), then the client can be confident that the <code>ech_update_auth</code> extension in it was set by the legitimate domain owner. An attacker cannot spoof that without breaking DNSSEC or the CA system, respectively. Thus, the pinned keys or certificate authority in that config are trustworthy. This is the ideal scenario.
- Well-known HTTPS: If fetched from <code>https://example.com/.well-known/ech</code> and the certificate is valid for <code>example.com</code>, then initial trust is as good as the CA system's security for that domain.
- Preconfigured (e.g., in an application): If the client is pre-loaded with certain ECH keys (not common, but possible in some apps), initial trust is given by that preload.<a href="#section-14-2" class="pilcrow">¶</a></p>
<p id="section-14-3"><strong>Signature and Proof Verification:</strong> Clients must correctly implement verification for each method:
- For RPK signatures, a cryptographic signature scheme like Ed25519, ECDSA, or RSA-PSS must be used, with adequate strength. The <code>SignatureScheme</code> registry from TLS 1.3 provides options; servers and clients should prefer schemes with no known weaknesses (e.g., avoid RSA PKCS1 v1.5, prefer PSS).
- The design intentionally mixes in a timestamp to limit replay. If an attacker recorded an old <code>ech_config_update</code> and later the server's config changes, the attacker might try to replay the old one to trick a client into reverting to an old key (which the attacker might have compromised). By including a validity interval (explicitly in DNSSEC's RRSIG and implicitly via HMAC timestamp in RPK), clients can detect stale updates. Clients MUST check these and reject obviously expired ones. However, note that time-based mechanisms rely on the client's clock. A client with a very wrong clock might erroneously accept or reject signatures. This is a general issue for TLS as well (cert expirations). It's assumed clients have reasonably correct time.
- In PKIX, the existing CA trust and revocation is leveraged. One additional consideration: a compromised ECH signing certificate (with the special EKU) could be used by an attacker (who also has some network MITM ability) to sign malicious updates. This is analogous to a compromised server certificate letting an attacker impersonate a site. The risk is mitigated by CAs being able to revoke the cert. Clients that do OCSP/CRL checks should apply them to the ECH signing certificate. Also, importantly, that certificate is restricted by name and EKU, so its misuse is limited to that context. If an attacker somehow obtains a fraudulent ECH signing certificate from a vulnerable CA (e.g., CA misissued a certificate for <code>front.example.net</code> with ECH EKU), they could sign bogus ECH configs. This risk is very low if CAs follow authentication procedures. But as a safeguard, clients might treat ECH signing certs with similar or higher caution as normal web certs.
- For DNSSEC, security hinges on the DNSSEC trust chain. If an adversary can crack or forge DNSSEC (e.g., by a rogue root key, or an algorithm break), they could forge an ECH config proof. However, DNSSEC (with, say, RSA-2048 or ECDSA P-256 at the root) is considered secure at present. Implementations need to ensure they validate the cryptographic signatures correctly and handle corner cases (like DNSSEC insecure delegations or unsupported algorithms) properly. If the client cannot validate the chain fully, it should not accept the update on faith.
- One specific DNSSEC consideration: The proof as structured might not always include intermediate (parent zone) keys. A client that doesn't already have the parent's DNSKEY might need to fetch it. If an attacker could interfere with that fetch (downgrade or block), they might try to make the client think the proof is valid when it's not. However, the design expects clients that advertise DNSSEC support to either have a validating resolver or be capable of full validation themselves. If they can't complete the chain, they should treat it as failure.<a href="#section-14-3" class="pilcrow">¶</a></p>
<p id="section-14-4"><strong>Integrity of the Handshake:</strong> The <code>ech_config_update</code> extension is encrypted and part of the handshake's integrity (Finished) check. If an attacker tries to modify or inject an update, it will fail the handshake or verification:
- A MITM who doesn't have the server's handshake keys cannot modify EncryptedExtensions without detection, as the Finished check would fail.
- An attacker could attempt to strip the <code>ECHConfigUpdateSupport</code> from the ClientHelloOuter (if they can modify ClientHello). However, the ClientHello is only partially protected (not encrypted, but some parts like random, etc., are covered in key schedule, though extensions are not integrity-protected in ClientHello). A sophisticated attacker with ability to modify CHOuter could remove the extension. In that case, the server wouldn't send an update. The handshake might then proceed without client getting the config. This is effectively a denial-of-service on the update mechanism. However, note that an attacker in such a position can also simply block ECH entirely or do other mischief. Stripping this extension doesn't give them a clear advantage unless their goal is specifically to prevent the client from getting new keys (maybe to enable a later attack when the old keys expire). While possible, this is a narrow window and detectable if the server expects to see client support (though the server can't easily tell it was stripped vs client not supporting).
- If an attacker replays an old ClientHello from the client (replay attack), TLS 1.3 has randomness and will fail (the server's Hello would be different or handshake keys wouldn't match what client expects), so that's not a vector.
- If an attacker somehow got the server's handshake key (compromise of ephemeral key?), they could potentially observe EncryptedExtensions. But by then, presumably, they could impersonate the server anyway. At that point, ECH is broken by that compromise, which is out of scope (that's an active attack requiring ephemeral key theft in near-real-time, extremely difficult).
- A rogue server (or a CDN node) that doesn't have authority to update ECH but still terminates TLS could attempt to send a fake update (e.g., a malicious server in a cluster). If it doesn't have the signing key or cert, the client will reject the signature. The client will then presumably not use that update. This is actually a desirable outcome: it prevents an unauthorized backend from altering ECH configs arbitrarily. (For instance, if a CDN fronts for multiple origins, the origin operator may keep the ECH update signing key, so even if the CDN tried to send clients a different config for some reason, it couldn't sign it correctly.)
- However, one must consider scenario: server sends an update that the client cannot verify (maybe due to bug or misconfiguration). The client ignores it. Does that create a vulnerability? It could mean the client continues using an old config that might be about to expire or be compromised. If an attacker blocked the valid update and made it look invalid, they might hope the client continues with an old key that the attacker has cracked. But blocking or modifying the update should either break handshake or make it unverifiable. If handshake continues (like attacker only modifies signature to break it, but not other fields), the client just ignores update. It might eventually fail when the server stops accepting old ECH (server might then send ech_required alert or refuse connections). So it's a possible denial-of-service angle, but not a silent break of security. The client and server will notice a mismatch eventually (client fails connections, etc.).
- Therefore, authenticity is strong, with the main risk being an attacker preventing updates (leading to connectivity issues, not compromise).<a href="#section-14-4" class="pilcrow">¶</a></p>
<p id="section-14-5"><strong>Client Behavior on Failure Cases:</strong> If any update verification fails, the client should fall back to standard behaviors:
- If ECH was accepted but update failed to verify, the connection is still good so there's no security issue; the client just didn't get the new key. It may log telemetry so the operator can see if many clients are failing to verify (which could indicate a configuration issue or attack).
- If ECH was rejected and update failed, the client is in a predicament: it still doesn't have a valid config. It might retry using a different strategy (e.g., query DNS directly with DNSSEC if available, or wait and try later). But it SHOULD NOT just proceed with the outer connection to send sensitive data, as that would violate the intent of ECH (especially if the server indicated ECH was required). The recommended approach is to treat it as a connection failure from the perspective of the application. This highlights that an active attacker could cause temporary denial of service by tampering with the update, but not read the traffic to the hidden domain (since the client won't send any).
- In theory, a client that supports multiple methods could, after a failure, try another method if available. For instance, if PKIX signature failed but DNSSEC data was present (just hypothesizing if we allowed multiple proofs), it could try verifying DNSSEC. However, our design currently sends one method per extension invocation. The server could possibly send multiple <code>ech_config_update</code> extensions (one per method) to provide redundancy. We didn't specify that, but if it did, a client should take the first one that verifies and ignore others. There's no mechanism defined for multiple, so it's moot unless an extension of spec adds it.
- The privacy goal is that even if attacker causes fallback to outer, the client will not reveal the true SNI to the attacker in cleartext. In our recommended fallback, the outer SNI is a fronting name, not the real one, so that's preserved. If a client gave up and connected without ECH with real SNI, privacy is lost. Therefore, we discourage that unless the user explicitly bypasses (like some browsers might allow fallback if user says proceed despite privacy risk).<a href="#section-14-5" class="pilcrow">¶</a></p>
<p id="section-14-6"><strong>Server Operational Considerations:</strong>
- Servers must keep their update signing keys secure. If a TOFU key is compromised, an attacker who can MITM could impersonate updates (and also the outer pinned certificate possibly). If detected, the server should remove that key's hash from <code>trusted_keys</code> in a new update (which it must sign with another still-trusted key or use DNSSEC/PKIX method to establish a fresh trust). This is tricky if the key was the only trust anchor. This argues for possibly having multiple keys in <code>trusted_keys</code> and/or having the ability to fall back to DNSSEC or PKIX if a pin is suspected compromised. It's analogous to SSH keys: if you suspect a known host key is stolen, you have to update out-of-band.
- If the PKIX certificate for ECH signing is compromised or expired, the server should get a new one and can send updates signed by the new one, but clients won't trust it unless the old config's <code>ech_update_auth</code> already allowed the new one's SPKI or the client can chain trust. Ideally, the server would have listed a hash of the new cert's key in <code>trusted_keys</code> too, or simply rely on the CA trust (the client will accept any certificate that chains to a root with that EKU and name).
- Algorithm agility:
  - The pinned keys method allows any signature scheme (advertised by algorithm field). If a particular algorithm becomes weak (say SHA-1, though we wouldn't use it here anyway), it should not be used. The registry of SignatureScheme can evolve. Clients and servers should use strong ones (e.g., Ed25519, Ed448, ECDSA with P-256/384, RSA-PSS with SHA256/384, etc.).
  - DNSSEC agility is at DNS level (e.g., from RSA to ECDSA to post-quantum if ever).
  - PKIX agility is as usual (move to better algorithms as needed; if PQC comes, define an EKU still works with new algorithm keys).
- Interoperability: If a client doesn't support a method the server uses exclusively, no update happens. At worst, the server rotates keys and those clients that couldn't get the update have to rely on other means (maybe a fresh DNS fetch) or fail. To minimize this, servers can either support multiple methods or at least ensure that if they choose one method, the majority of clients implement it. In practice, we expect browsers to implement both PKIX and DNSSEC methods possibly, and perhaps RPK if they're comfortable. Smaller clients might only do PKIX, etc. Over time, operational experience will show what's most useful. This design is flexible to accommodate multiple or just one method.<a href="#section-14-6" class="pilcrow">¶</a></p>
<p id="section-14-7"><strong>Reserved Future Mechanisms:</strong>
We reserved a method bit (0x08) for "public name mapping authentication" (the NOPE-style concept). If in future a more advanced scheme is standardized (for example, a way to verifiably bind the public name to the hidden name cryptographically, beyond just pinning keys), that could be introduced. This would likely involve a different kind of proof or extension. We have left a slot so that clients and servers negotiating that won't clash with these bits. For now, that method is not defined, and clients MUST NOT set the 0x08 bit and servers MUST NOT use method code 4 in <code>ech_config_update</code>. When/if a future RFC defines it, this spec's IANA section allocates that codepoint to them.<a href="#section-14-7" class="pilcrow">¶</a></p>
<p id="section-14-8"><strong>Denial of Service and Performance:</strong>
- Handling an extra extension and verifying signatures has performance costs. DNSSEC validation is perhaps the heaviest (parsing and verifying possibly multiple RSA signatures). However, ECH itself is already a somewhat heavy operation (HPKE, etc.), and these will occur infrequently (only on config rotation events, not every connection necessarily). The size of the extension might cause the ServerHello/EncryptedExtensions to be larger (especially if including a certificate chain or DNS records). This could risk exceeding the limit for early handshake flights (TLS has some message size considerations, though typically up to 2^14 bytes is allowed). A DNSSEC proof or certificate might be a couple of kilobytes. This is usually fine, but in extreme cases could cause fragmentation at the TLS record layer or require the client to acknowledge handshake messages (in UDP-based QUIC, large handshakes might need retry). Implementers should be mindful if using in QUIC: the initial packets have limits, but since this is after SH, server can usually send multiple handshake packets. It should be okay.
- Flooding: An attacker cannot trigger an <code>ech_config_update</code> unless it triggers a handshake. If an attacker opens many handshakes to the server (like a DDoS) claiming support, the server might send many cert chains or proofs, consuming bandwidth. This is a consideration but similar to them doing TLS handshakes with client auth, etc. Rate limiting or stateless cookies in HRR (for anti-DoS) could mitigate some initial flood. Not a unique vulnerability of this, just make sure not to send a 10KB DNSSEC proof to someone who hasn't done a cookie exchange if under heavy load.
- Client storage: The client might end up storing multiple configs (like old and new). ECH spec already suggests clients cache by config id and manage TTL. The update's signature validity might serve as a soft TTL. The client should discard old config when expired or when replaced. Also, track which source it came from (if an attacker somehow injected an update with no valid sign, the client wouldn't store).
- <strong>Misordering:</strong> If multiple updates happen quickly, a client could receive an outdated one after a newer one via different channel. E.g., server rotates key, publishes DNS update (DNSSEC), then also during handshake sends an update, but maybe the DNS record had an even newer key. A client might connect, get older update, then later do DNS and see new. This is generally benign; the freshest should prevail. If a client receives an update but then immediately sees another update with a valid signature (like different timestamp or different config), it should prefer the one with the later valid time or maybe the one from handshake since it's immediate. But if conflicting, something's wrong (maybe attacker trying to confuse). In normal cases, operator syncs things or uses one channel primarily.
- <strong>Privacy considerations:</strong> Already mostly discussed in introduction and security – in summary, no new major leak except a minor capability flag, and improved privacy by enabling more flexible public names. The actual hidden origin is never revealed in any of these update structures (the DNSSEC proof is about the public name, the certificate is for public name, the pinned keys are associated with public name). So an attacker who somehow sees the extension (which they shouldn't, as it's encrypted) would still only learn about the fronting domain.<a href="#section-14-8" class="pilcrow">¶</a></p>
<p id="section-14-9"><strong>IANA Considerations</strong> will ensure codepoints are allocated to avoid collisions (this is not a direct security issue but required for protocol stability).<a href="#section-14-9" class="pilcrow">¶</a></p>
<p id="section-14-10">Overall, this mechanism enhances the security of ECH by ensuring clients get authenticated updates (preventing downgrade or sticky-key attacks) and by allowing alternatives to PKI for the outer handshake (preventing situations where inability to get a certificate for a cover name stops deployment). The major security caveats revolve around initial bootstrapping trust and handling failures gracefully, which we have addressed with normative requirements and recommendations above.<a href="#section-14-10" class="pilcrow">¶</a></p>
</section>
</div>
<div id="privacy-considerations">
<section id="section-15">
      <h2 id="name-privacy-considerations">
<a href="#section-15" class="section-number selfRef">15. </a><a href="#name-privacy-considerations" class="section-name selfRef">Privacy Considerations</a>
      </h2>
<p id="section-15-1">ECH itself is a privacy technology aimed at hiding the client's intended server name from observers. This document builds on ECH and tries to maintain or improve privacy:
- By allowing the use of unique or diversified public names (enabled by the TOFU pinning method), it potentially increases the anonymity set as discussed. Instead of one fixed fronting domain that might allow correlating traffic, servers could use a pool of fronts, even ephemeral ones.
- The trade-off is that frequent public name changes could also act as a fingerprint if not carefully managed (e.g., if each client gets a unique front name, then that front name becomes a stable identifier for that client across sessions). To mitigate this, deployments should consider reusing front names among many clients or expiring them quickly after use. The mechanism here doesn't dictate strategy, just makes it possible.
- The presence of the <code>encrypted_client_hello_update_support</code> extension in ClientHelloOuter might reveal something about the client's capabilities or configuration. For example, if some clients only support PKIX and others support DNSSEC, an observer who can see the ClientHelloOuter (which is plaintext) might distinguish them. However, the outer ClientHello already indicates ECH support (by containing a GREASE or real ECH extension, and the SNI being a public name likely known as such). The additional extension probably doesn't add much more identifying info beyond that. Ideally, most ECH-supporting clients will eventually implement all common methods, so they'll all advertise the same bits (e.g., a standard browser might do both PKIX and DNSSEC, making the extension value uniform across many clients).
- An on-path attacker who can see the outer ClientHello can see the support bits. But since that attacker is presumably preventing ECH (or else the attacker can't see inner SNI anyway), knowing the support bits doesn't directly help circumvent them. At most, if the attacker sees that the client supports DNSSEC, they might attempt a DNSSEC-related trick (like feeding a bad proof or blocking it). Similarly, if they see the client does not support DNSSEC, they know attacking the DNS channel could be fruitful. But the attacker likely already knows the general distribution of such support by client fingerprint or version. So not a huge new vulnerability.
- The actual ECHConfigList updates are encrypted in the handshake, so no privacy issue there (they might contain the public name in clear as part of config, but since the whole thing is encrypted in TLS handshake, passive observers can't see it). Even if they could, it's just the same public name that was in the outer SNI anyway, so nothing new.
- When the client falls back to an outer handshake, the hidden origin's name is not exposed in SNI (the client continues to use the public name). This mechanism ensures that even in the retry scenario, the hidden name remains protected. Some earlier ECH fallback proposals might have considered revealing the real name if needed (which would compromise privacy); we avoid that by pinning or alternate auth of the public name.
- One privacy drawback: A client might end up connecting twice (once with outer fallback, then again with ECH) which doubles the connections an observer sees. An observer could notice a pattern: e.g., client connects to <code>front.example.net</code>, does some TLS handshake and then another to the same <code>front.example.net</code> shortly after. This could hint that ECH was attempted and failed first time. However, since <code>front.example.net</code> likely is used by many as a front domain, this doesn't directly reveal which hidden site was the target. It does signal "this client tried ECH to something behind front.example.net, then succeeded second try," which could draw attention, but not identification of the site beyond that front grouping. Over time, as config updates are less frequent, most connections will be one try only.
- If an attacker tries to exploit the update mechanism to deduce something (like timing when a site rotates keys, etc.), they might glean that keys changed if they see handshakes with <code>ech_config_update</code> happening. But key rotation timing is usually not secret, and an outside observer cannot see the content of the extension to know what changed, only perhaps infer that an update happened if sizes differ or so. This is a minor concern.
- Use of DNSSEC involves sending DNS records which include domain names (the <code>_encrypted.front.example.net</code> etc.). Those are already public info in DNS. Embedding them in the TLS handshake (encrypted) is fine. The client when validating might do additional DNS queries (for parent DNSKEY). Those queries could be observed by the network and reveal that the client is doing DNSSEC for that domain. But a client doing DNSSEC likely does many validations anyway. And if using a local validating resolver, no extra queries on wire from client. If the client itself fetches parent keys, those queries could slightly expose interest in the domain. However, if ECH was used at all, the client already queried DNS for the initial config (unless it had cached). So no new info leaked that the client didn't already in trying ECH.<a href="#section-15-1" class="pilcrow">¶</a></p>
<p id="section-15-2"><strong>In summary</strong>, the mechanism is designed to preserve the privacy goals of ECH. It avoids falling back to clear SNI, and it contains authenticated channels for delivering needed info without revealing the hidden target. Implementers should still adhere to best practices (like not using pinned keys in ways that uniquely identify users, and ensuring the consistent sending of the support extension). This spec in itself introduces no new cookies, identifiers, or tracking mechanisms beyond what TLS and DNS already require.<a href="#section-15-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="iana">
<section id="section-16">
      <h2 id="name-iana-considerations">
<a href="#section-16" class="section-number selfRef">16. </a><a href="#name-iana-considerations" class="section-name selfRef">IANA Considerations</a>
      </h2>
<p id="section-16-1">This document requires several new registrations:<a href="#section-16-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-16-2">
<li id="section-16-2.1">
          <p id="section-16-2.1.1"><strong>TLS ExtensionType:</strong> Two new TLS extension codes in the "TLS ExtensionType Values" registry:<a href="#section-16-2.1.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-16-2.1.2.1">
              <p id="section-16-2.1.2.1.1"><code>encrypted_client_hello_update_support</code> (tentative name): A ClientHello extension. This extension is only sent by the client. The recommended value is TBD2 (an available code point in the 0xff00-0xffff range for private use during draft stage, to be allocated in the permanent range upon RFC publication).<a href="#section-16-2.1.2.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-16-2.1.2.2">
              <p id="section-16-2.1.2.2.1"><code>ech_config_update</code>: A new extension used in EncryptedExtensions (and potentially in HelloRetryRequest if that gets allowed in some future revision). Recommended code point TBD3. This extension will be marked for usage in TLS 1.3 handshake only, not applicable to earlier versions.<a href="#section-16-2.1.2.2.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-16-2.1.3">
The entries should be added as follows (if this were an RFC, in IANA's TLS Extensions registry):
Value: TBD2 (assigned by IANA)
Extension Name: encrypted_client_hello_update_support
TLS 1.3: CH
Recommended: N (since it's only useful in context of ECH which is still not recommended for all TLS use)
Reference: this document Value: TBD3
Extension Name: ech_config_update
TLS 1.3: EE, (HRR?)
Recommended: N
Reference: this document
(The "TLS 1.3" column indicates in which messages it may appear: CH = ClientHello, EE = EncryptedExtensions, HRR = HelloRetryRequest. We might leave HRR blank since currently we decided not to use it in this specification. If a future revision allows it, we will update this accordingly.)<a href="#section-16-2.1.3" class="pilcrow">¶</a></p>
</li>
        <li id="section-16-2.2">
          <p id="section-16-2.2.1"><strong>ECHConfig Extension Type:</strong> A new code point in the "ECH Config Extension Type Values" registry (established by the ECH specification draft).
- Name: <code>ech_update_auth</code>
- Value: TBD1 (we can request a specific value or let IANA choose the next available; perhaps if 0xff03 is next after what ECH spec has defined, we take that).
- Purpose: Indicates supported update authentication methods and pin hashes.
- Reference: this document<a href="#section-16-2.2.1" class="pilcrow">¶</a></p>
</li>
      </ol>
<p id="section-16-3">This will allow ECHConfigContents to include an extension of this type. It should be marked as "OK to appear in DNS SVCB parameter ech and in ECHConfig structure".<a href="#section-16-3" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-16-4">
<li id="section-16-4.1">
          <p id="section-16-4.1.1"><strong>Extended Key Usage OID:</strong> We need an OID for "ECH Configuration Signing". The IANA "SMI Security for PKIX Extended Key Purpose" registry (or if not IANA, maybe it's maintained by ISO/ITU but RFCs often register OIDs under 1.3.6.1.5.5.7.3 (id-kp) arc). For example, TLS server auth is id-kp-serverAuth (1.3.6.1.5.5.7.3.1), code signing is .3.3, etc. We request an OID like 1.3.6.1.5.5.7.3.?? for ECH config signing. We need to coordinate an unused number. Let's assume OID 1.3.6.1.5.5.7.3.33 (just an arbitrary not yet assigned in RFC, as many EKUs exist e.g., 1.3.6.1.5.5.7.3.31 is time stamping, etc. Actually, let's not guess number; just say "an OID TBD by IANA (or assigned from that arc) to be used as id-kp-echConfigSigning".
- The OID will be referenced and described here as "TLS ECH Config Signing EKU".
- IANA might delegate the assignment to "SMI Security WG or Expert Review". Historically, such OIDs in that arc have been assigned in RFCs. We provide the OID or ask IANA to assign the next in sequence.
- The EKU allows a certificate to assert: "I am allowed to sign ECHConfig updates for the domain(s) in my SAN".
- So the certificate profile: X.509 v3 extension extendedKeyUsage contains this OID.<a href="#section-16-4.1.1" class="pilcrow">¶</a></p>
</li>
      </ol>
<p id="section-16-5">We will add text:
"IANA is requested to allocate a new OID for ExtendedKeyUsage in the PKIX EKU registry, with the name id-kp-echConfigSigning. The OID is to be under the id-kp (1.3.6.1.5.5.7.3) arc. The exact numerical assignment is to be coordinated with IANA/IETF. The intended usage is in X.509 certificates that are used in the context of authenticating ECH Config updates via the PKIX method described in this document. Certificates including this EKU are asserting that the public key is authorized to sign ECH configuration updates for the names in the certificate, and SHOULD NOT be accepted for other uses (TLS server authentication without this specific purpose, etc., unless they also contain the appropriate EKUs for those uses)."<a href="#section-16-5" class="pilcrow">¶</a></p>
<p id="section-16-6">If there's an existing IANA registry for EKU (the "SMI Security for PKIX EKU" has OIDs, some RFC might have one for ESNI/ECH but I doubt it), we ensure to reference that.<a href="#section-16-6" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-16-7">
<li id="section-16-7.1">
          <p id="section-16-7.1.1"><strong>Method Flags Registry (Potentially):</strong> We have the <code>methods</code> bitmask. We might want to establish a registry for ECH Update Authentication Methods (the bit assignments and corresponding <code>ECHUpdateMethodType</code> enum). This could be a simple table:
- 0x01: RPK (Trust on First Use key signature)
- 0x02: PKIX (Certificate signature)
- 0x04: DNSSEC (DNSSEC proof)
- 0x08: RESERVED (for future Public Name mapping auth)
- 0x10, 0x20, etc. unassigned (for future)
Actually since it's a 8-bit field (we used uint8 for methods), it can go up to 0x80. We might ask IANA to manage these values. But because it's in an extension in ECHConfig, and not a TLS content type or handshake type, it might be fine to just let this document define the known bits and say future assignments via Standards Action or IETF Review.<a href="#section-16-7.1.1" class="pilcrow">¶</a></p>
</li>
      </ol>
<p id="section-16-8">Possibly it's easier to not formalize a registry now, but we can be forward-looking:
"IANA is requested to establish a sub-registry under the ECH registry for ECH Update Authentication Methods (by value and corresponding handshake extension usage). Initial values are: 1=RPK, 2=PKIX, 3=DNSSEC. Future assignments are to be made via IETF Review to maintain interoperability."<a href="#section-16-8" class="pilcrow">¶</a></p>
<p id="section-16-9">Actually, our <code>ECHUpdateMethodType</code> enum has values 1,2,3 (not bitmask, but actual method field values). We should ensure no confusion:
- In <code>ech_update_auth.methods</code> (bitmask), bits 0x01,0x02,0x04 correspond to those.
- In the handshake extension's <code>method</code> field (ECHUpdateMethodType), we gave them as 1=RPK,2=PKIX,3=DNSSEC. We can have IANA register these numeric codepoints similarly, likely in the same registry or separate.<a href="#section-16-9" class="pilcrow">¶</a></p>
<p id="section-16-10">Perhaps define one registry "ECH Config Update Methods" with initial assignments:<a href="#section-16-10" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-16-11.1">
          <p id="section-16-11.1.1">Codepoint 1 — RPK: Update signed with pinned key (trust on first use)<a href="#section-16-11.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-16-11.2">
          <p id="section-16-11.2.1">Codepoint 2 — PKIX: Update signed with PKIX certificate<a href="#section-16-11.2.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-16-11.3">
          <p id="section-16-11.3.1">Codepoint 3 — DNSSEC: Update authenticated via DNSSEC proof<a href="#section-16-11.3.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-16-11.4">
          <p id="section-16-11.4.1">Codepoint 4 — Reserved for public name mapping auth (do not use)<a href="#section-16-11.4.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-16-11.5">
          <p id="section-16-11.5.1">Codepoints 5–255 — Unassigned<a href="#section-16-11.5.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-16-12">The bitmask in <code>ech_update_auth</code> corresponds to these values as flags (bit position equal to codepoint). Value 0 is not used.<a href="#section-16-12" class="pilcrow">¶</a></p>
<p id="section-16-13">Actually, setting up this registry is wise to avoid collisions if future docs define new methods.<a href="#section-16-13" class="pilcrow">¶</a></p>
<p id="section-16-14">So yes, let's do that.<a href="#section-16-14" class="pilcrow">¶</a></p>
<p id="section-16-15">So summarizing IANA:
- 2 TLS extensions
- 1 ECHConfig extension
- 1 EKU OID
- 1 registry for update methods (with initial assignments including reserved).<a href="#section-16-15" class="pilcrow">¶</a></p>
<p id="section-16-16">We ensure to mention the reserved codepoint for NOPE-style (value 4 in registry, flag 0x08).<a href="#section-16-16" class="pilcrow">¶</a></p>
</section>
</div>
<div id="state-machine">
<section id="section-17">
      <h2 id="name-retry-state-machine">
<a href="#section-17" class="section-number selfRef">17. </a><a href="#name-retry-state-machine" class="section-name selfRef">Retry State Machine</a>
      </h2>
<p id="section-17-1">TBD.<a href="#section-17-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="deployment-considerations">
<section id="section-18">
      <h2 id="name-deployment-considerations">
<a href="#section-18" class="section-number selfRef">18. </a><a href="#name-deployment-considerations" class="section-name selfRef">Deployment Considerations</a>
      </h2>
<p id="section-18-1">TBD.<a href="#section-18-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="reserved-nope">
<section id="section-19">
      <h2 id="name-reserved-code-points">
<a href="#section-19" class="section-number selfRef">19. </a><a href="#name-reserved-code-points" class="section-name selfRef">Reserved Code Points</a>
      </h2>
<p id="section-19-1">TBD.<a href="#section-19-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec-combined-references">
<section id="section-20">
      <h2 id="name-references">
<a href="#section-20" class="section-number selfRef">20. </a><a href="#name-references" class="section-name selfRef">References</a>
      </h2>
<div id="sec-normative-references">
<section id="section-20.1">
        <h3 id="name-normative-references">
<a href="#section-20.1" class="section-number selfRef">20.1. </a><a href="#name-normative-references" class="section-name selfRef">Normative References</a>
        </h3>
<dl class="references">
<dt id="RFC2119">[RFC2119]</dt>
        <dd>
<span class="refAuthor">Bradner, S.</span>, <span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 2119</span>, <span class="seriesInfo">DOI 10.17487/RFC2119</span>, <time datetime="1997-03" class="refDate">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8174">[RFC8174]</dt>
        <dd>
<span class="refAuthor">Leiba, B.</span>, <span class="refTitle">"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 8174</span>, <span class="seriesInfo">DOI 10.17487/RFC8174</span>, <time datetime="2017-05" class="refDate">May 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8446">[RFC8446]</dt>
        <dd>
<span class="refAuthor">Rescorla, E.</span>, <span class="refTitle">"The Transport Layer Security (TLS) Protocol Version 1.3"</span>, <span class="seriesInfo">RFC 8446</span>, <span class="seriesInfo">DOI 10.17487/RFC8446</span>, <time datetime="2018-08" class="refDate">August 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8446">https://www.rfc-editor.org/info/rfc8446</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9180">[RFC9180]</dt>
        <dd>
<span class="refAuthor">Barnes, R.</span>, <span class="refAuthor">Bhargavan, K.</span>, <span class="refAuthor">Lipp, B.</span>, and <span class="refAuthor">C. Wood</span>, <span class="refTitle">"Hybrid Public Key Encryption"</span>, <span class="seriesInfo">RFC 9180</span>, <span class="seriesInfo">DOI 10.17487/RFC9180</span>, <time datetime="2022-02" class="refDate">February 2022</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9180">https://www.rfc-editor.org/info/rfc9180</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9460">[RFC9460]</dt>
        <dd>
<span class="refAuthor">Schwartz, B.</span>, <span class="refAuthor">Bishop, M.</span>, and <span class="refAuthor">E. Nygren</span>, <span class="refTitle">"Service Binding and Parameter Specification via the DNS (SVCB and HTTPS Resource Records)"</span>, <span class="seriesInfo">RFC 9460</span>, <span class="seriesInfo">DOI 10.17487/RFC9460</span>, <time datetime="2023-11" class="refDate">November 2023</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9460">https://www.rfc-editor.org/info/rfc9460</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.ietf-tls-svcb-ech">[I-D.ietf-tls-svcb-ech]</dt>
        <dd>
<span class="refAuthor">Schwartz, B. M.</span>, <span class="refAuthor">Bishop, M.</span>, and <span class="refAuthor">E. Nygren</span>, <span class="refTitle">"Bootstrapping TLS Encrypted ClientHello with DNS Service Bindings"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-tls-svcb-ech-08</span>, <time datetime="2025-06-16" class="refDate">16 June 2025</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-tls-svcb-ech-08">https://datatracker.ietf.org/doc/html/draft-ietf-tls-svcb-ech-08</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.ietf-tls-wkech">[I-D.ietf-tls-wkech]</dt>
      <dd>
<span class="refAuthor">Farrell, S.</span>, <span class="refAuthor">Salz, R.</span>, and <span class="refAuthor">B. M. Schwartz</span>, <span class="refTitle">"A well-known URI for publishing service parameters"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-tls-wkech-09</span>, <time datetime="2025-09-02" class="refDate">2 September 2025</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-tls-wkech-09">https://datatracker.ietf.org/doc/html/draft-ietf-tls-wkech-09</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</div>
<div id="sec-informative-references">
<section id="section-20.2">
        <h3 id="name-informative-references">
<a href="#section-20.2" class="section-number selfRef">20.2. </a><a href="#name-informative-references" class="section-name selfRef">Informative References</a>
        </h3>
<dl class="references">
<dt id="I-D.ietf-tls-esni">[I-D.ietf-tls-esni]</dt>
      <dd>
<span class="refAuthor">Rescorla, E.</span>, <span class="refAuthor">Oku, K.</span>, <span class="refAuthor">Sullivan, N.</span>, and <span class="refAuthor">C. A. Wood</span>, <span class="refTitle">"TLS Encrypted Client Hello"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-tls-esni-25</span>, <time datetime="2025-06-14" class="refDate">14 June 2025</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-ietf-tls-esni-25">https://datatracker.ietf.org/doc/html/draft-ietf-tls-esni-25</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</div>
</section>
</div>
<div id="authors-addresses">
<section id="appendix-A">
      <h2 id="name-authors-addresses">
<a href="#name-authors-addresses" class="section-name selfRef">Authors' Addresses</a>
      </h2>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Nick Sullivan</span></div>
<div dir="auto" class="left"><span class="org">Cryptography Consulting LLC</span></div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Martin Thomson</span></div>
<div dir="auto" class="left"><span class="org">Mozilla</span></div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Dennis Jackson</span></div>
<div dir="auto" class="left"><span class="org">Mozilla</span></div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>
</body>
</html>
